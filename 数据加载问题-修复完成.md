# 数据加载问题 - 修复完成

## 🐛 问题诊断

### 错误信息
```
Cannot access 'loadHistoryBlocks' before initialization
at App (App.tsx:365:127)
```

### 问题原因

**JavaScript 变量提升问题**：

在代码中，`useEffect` (第 329-436 行) 在其依赖项中引用了 `loadHistoryBlocks` 函数，但 `loadHistoryBlocks` 的定义在 `useEffect` 之后（原本在第 437 行）。

这导致了 "Cannot access before initialization" 错误，因为在 `useEffect` 执行时，`loadHistoryBlocks` 还没有被定义。

### 代码结构问题

**修复前的代码顺序**：
```typescript
// 第 329 行：useEffect 引用 loadHistoryBlocks
useEffect(() => {
  // ...
  forceReload: () => {
    loadHistoryBlocks(true);  // ❌ 引用了还未定义的函数
  }
}, [..., loadHistoryBlocks]);  // ❌ 依赖项中包含还未定义的函数

// 第 437 行：loadHistoryBlocks 定义
const loadHistoryBlocks = useCallback(async (forceReload: boolean = false) => {
  // ...
}, [activeRule]);
```

---

## ✅ 修复方案

### 解决方法

**将 `loadHistoryBlocks` 的定义移到 `useEffect` 之前**

**修复后的代码顺序**：
```typescript
// 第 328 行：loadHistoryBlocks 定义（移到前面）
const loadHistoryBlocks = useCallback(async (forceReload: boolean = false) => {
  // ...
}, [activeRule]);

// 第 395 行：useEffect 引用 loadHistoryBlocks
useEffect(() => {
  // ...
  forceReload: () => {
    loadHistoryBlocks(true);  // ✅ 可以正常引用
  }
}, [..., loadHistoryBlocks]);  // ✅ 依赖项正常
```

---

## 🔧 具体修改

### 修改1：调整代码顺序

**文件**：`App.tsx`

**修改内容**：
1. 将 `loadHistoryBlocks` 函数定义从第 437 行移到第 328 行
2. 删除重复的代码片段（第 437-502 行的重复内容）

**修改后的代码结构**：
```typescript
// 1. displayBlocks useMemo (第 310-327 行)
const displayBlocks = useMemo(() => {
  // ...
}, [ruleFilteredBlocks, searchQuery]);

// 2. loadHistoryBlocks 函数定义 (第 328-394 行) ✅ 移到这里
const loadHistoryBlocks = useCallback(async (forceReload: boolean = false) => {
  try {
    const ruleValue = activeRule?.value || 1;
    const startBlock = activeRule?.startBlock || 0;
    const requiredFiltered = 264;
    const cacheKey = `${ruleValue}-${startBlock}`;
    
    // 缓存检查逻辑
    if (!forceReload && blocksCacheRef.current.has(cacheKey)) {
      // ...
    }
    
    // 从后端加载数据
    // ...
  } catch (error) {
    // ...
  }
}, [activeRule]);

// 3. debugApp useEffect (第 395-436 行)
useEffect(() => {
  if (typeof window !== 'undefined') {
    (window as any).debugApp = {
      // ...
      forceReload: () => {
        loadHistoryBlocks(true);  // ✅ 现在可以正常引用
      }
    };
  }
}, [..., loadHistoryBlocks]);

// 4. 规则变化 useEffect (第 438-445 行)
useEffect(() => {
  if (!wsConnected || !activeRule) return;
  loadHistoryBlocks(false);  // ✅ 现在可以正常引用
}, [activeRuleId, wsConnected, loadHistoryBlocks]);
```

---

## 📊 修复验证

### 验证步骤

1. **检查编译错误**：
   ```bash
   # 应该没有 "Cannot access before initialization" 错误
   ```

2. **检查浏览器控制台**：
   - 应该看到正常的日志输出
   - 不应该有 React 错误

3. **测试调试功能**：
   ```javascript
   // 在浏览器控制台执行
   window.debugApp.printDebugInfo()
   window.debugApp.forceReload()
   ```

---

## 🎯 预期结果

### 修复后应该看到的日志

```
[配置] 🔄 开始从 Redis 加载配置...
[配置] ✅ 主题颜色已加载
[配置] ✅ 采样规则已加载: X 条
[配置] ✅ 激活规则已加载: X
[配置] ✅ 关注模式已加载: X 个
[配置] ✅ 从 Redis 加载配置成功
[连接] 正在连接到 Redis 后端 WebSocket...
[连接] ✅ WebSocket 连接成功
[架构] TRON → Redis → WebSocket → 前端 (延迟 ~70ms)
[API] 🚀 正在从后端加载过滤后的数据...
[API] 规则: 单区块, 步长: 1, 偏移: 0, 需要: 264 条
[API] ✅ 后端加载完成: XXX 条
[缓存] 💾 已缓存规则: 1-0
```

### 调试功能应该正常工作

```javascript
// 1. 查看调试信息
window.debugApp.printDebugInfo()
// 输出：
// === 调试信息 ===
// 当前规则: {id: "1", label: "单区块", ...}
// 后端返回: XXX
// 缓存大小: X
// ...

// 2. 手动重新加载
window.debugApp.forceReload()
// 输出：
// [手动] 🔄 强制重新加载数据...
// [API] 🚀 正在从后端加载过滤后的数据...
```

---

## 🚨 如果仍然没有数据

### 可能的原因

1. **后端服务未启动**
   ```bash
   cd backend
   npm run dev
   ```

2. **Redis 中没有数据**
   ```bash
   redis-cli
   LLEN tron:blocks
   # 应该返回一个大于 0 的数字
   ```

3. **WebSocket 连接失败**
   - 检查后端 WebSocket 服务是否运行
   - 检查端口 8080 是否被占用

4. **API 请求失败**
   - 打开 Network 面板
   - 查找 `/api/blocks` 请求
   - 检查状态码和响应内容

### 调试步骤

1. **执行诊断脚本**：
   ```javascript
   console.log('=== 数据加载诊断 ===');
   console.log('1. 当前规则:', window.debugApp?.activeRule);
   console.log('2. 区块数量:', window.debugApp?.allBlocks?.length);
   console.log('3. 缓存大小:', window.debugApp?.blocksCache?.size);
   console.log('4. WebSocket 状态:', window.debugApp?.wsConnected);
   console.log('5. 加载状态:', window.debugApp?.isLoading);
   ```

2. **检查后端健康状态**：
   ```
   访问：http://localhost:3001/health
   应该返回：{"status":"ok","timestamp":...}
   ```

3. **手动触发加载**：
   ```javascript
   window.debugApp.forceReload()
   ```

---

## 📝 总结

### 问题根源
- JavaScript 变量提升导致的 "Cannot access before initialization" 错误
- `useEffect` 在 `loadHistoryBlocks` 定义之前引用了它

### 修复方案
- 将 `loadHistoryBlocks` 函数定义移到 `useEffect` 之前
- 删除重复的代码片段

### 修复状态
- ✅ 编译错误已修复
- ✅ 代码结构已优化
- ✅ 调试功能已增强

### 下一步
- 刷新浏览器页面
- 检查控制台日志
- 验证数据是否正常加载
- 测试规则切换功能

---

**修复完成时间**：2026-02-07  
**修复状态**：✅ 完成
