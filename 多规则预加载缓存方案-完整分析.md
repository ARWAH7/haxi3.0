# 多规则预加载缓存方案 - 完整分析

## 用户提出的方案

### 核心思路
1. **首次加载**：前端启动时，预加载 4 个默认规则（步长 1, 20, 60, 100）的数据，每个规则 264 条
2. **WebSocket 同步**：新区块到达时，根据区块高度判断符合哪些规则，分别更新对应规则的缓存
3. **及时清理**：不符合任何规则的数据及时清除，避免内存占用
4. **规则切换**：切换规则时直接使用缓存，0ms 延迟

### 示例场景

**首次加载**：
```
规则 1（步长1）：264 条数据 → 缓存 Map["1-0"]
规则 20（步长20）：264 条数据 → 缓存 Map["20-0"]
规则 60（步长60）：264 条数据 → 缓存 Map["60-0"]
规则 100（步长100）：264 条数据 → 缓存 Map["100-0"]
```

**WebSocket 推送新区块 79929120**：
```
检查步长1：79929120 % 1 === 0 ✅ → 更新缓存 Map["1-0"]
检查步长20：79929120 % 20 === 0 ✅ → 更新缓存 Map["20-0"]
检查步长60：79929120 % 60 === 0 ✅ → 更新缓存 Map["60-0"]
检查步长100：79929120 % 100 === 0 ✅ → 更新缓存 Map["100-0"]
```

**规则切换**：
```
从规则 1 切换到规则 20：
- 直接使用缓存 Map["20-0"]
- 耗时：0ms ✅
- 数据完整：✅（WebSocket 已同步更新）
```

---

## 方案可行性分析

### ✅ 优势

#### 1. 性能最优
- **规则切换**：0ms（直接使用缓存）
- **数据加载**：只在首次启动时加载
- **用户体验**：无感知切换

#### 2. 数据完整性
- **WebSocket 同步**：所有规则的缓存实时更新
- **无数据断层**：每个规则的缓存都是连续的
- **数据准确**：始终保持最新

#### 3. 内存可控
- **固定内存**：4 个规则 × 264 条 = 1056 条数据
- **及时清理**：不符合规则的数据不保存
- **内存占用**：约 0.5MB（可接受）

#### 4. 逻辑清晰
- **预加载**：启动时一次性加载
- **同步更新**：WebSocket 推送时更新所有规则
- **规则切换**：直接使用缓存

### ⚠️ 挑战

#### 1. 首次加载时间
- **问题**：需要加载 4 个规则的数据
- **耗时**：4 × 35ms = 140ms（可接受）
- **优化**：并行加载，实际耗时约 50-70ms

#### 2. WebSocket 同步逻辑
- **问题**：每个新区块需要检查 4 个规则
- **复杂度**：O(规则数量)，但规则数量固定为 4
- **性能影响**：可忽略（每个区块约 1ms）

#### 3. 动态规则
- **问题**：用户可能添加新规则（如步长 5, 10）
- **解决**：新规则首次使用时加载，然后加入同步更新列表

#### 4. 缓存过期
- **问题**：长时间不切换某个规则，缓存可能过期
- **解决**：WebSocket 持续同步，缓存始终最新

---

## 实现难度评估

### 🟢 难度：中等（可实现）

#### 后端修改（简单）
- **无需修改**：现有 API 已支持按规则过滤
- **并行加载**：前端发起 4 个并行请求

#### 前端修改（中等）
1. **预加载逻辑**（20 行代码）
   - 启动时并行加载 4 个规则
   - 存储到缓存 Map

2. **WebSocket 同步**（30 行代码）
   - 遍历所有已缓存的规则
   - 检查新区块是否符合每个规则
   - 更新对应规则的缓存

3. **规则切换**（5 行代码）
   - 检查缓存是否存在
   - 存在：直接使用（0ms）
   - 不存在：加载后加入同步列表

#### 测试验证（简单）
- 测试预加载
- 测试 WebSocket 同步
- 测试规则切换
- 测试内存占用

---

## 与现有方案对比

### 方案 1：强制重新加载（当前方案）
- **切换速度**：35-110ms
- **数据准确性**：✅ 完全准确
- **内存占用**：264 条（约 0.13MB）
- **用户体验**：⭐⭐⭐⭐
- **实现难度**：简单

### 方案 2：智能增量加载
- **切换速度**：0-110ms（取决于缺失数据量）
- **数据准确性**：✅ 完全准确
- **内存占用**：264 条 × 缓存规则数（约 0.13MB × N）
- **用户体验**：⭐⭐⭐⭐⭐
- **实现难度**：中等

### 方案 3：多规则预加载缓存（用户提出）
- **切换速度**：0ms ✅
- **数据准确性**：✅ 完全准确
- **内存占用**：1056 条（约 0.5MB）
- **用户体验**：⭐⭐⭐⭐⭐
- **实现难度**：中等

### 对比总结

| 方案 | 切换速度 | 数据准确性 | 内存占用 | 用户体验 | 实现难度 |
|------|---------|-----------|---------|---------|---------|
| 强制重新加载 | 35-110ms | ✅ | 0.13MB | ⭐⭐⭐⭐ | 简单 |
| 智能增量加载 | 0-110ms | ✅ | 0.13MB × N | ⭐⭐⭐⭐⭐ | 中等 |
| **多规则预加载** | **0ms** | ✅ | **0.5MB** | ⭐⭐⭐⭐⭐ | 中等 |

**结论**：多规则预加载缓存方案在性能和用户体验上最优，内存占用可接受。

---

## 推荐方案：多规则预加载缓存（增强版）

### 核心改进

#### 1. 智能预加载
- **默认规则**：启动时预加载 4 个默认规则（1, 20, 60, 100）
- **动态规则**：用户切换到新规则时，加载并加入同步列表
- **优先级**：最近使用的规则优先保留

#### 2. WebSocket 同步优化
- **批量更新**：新区块到达时，批量更新所有规则缓存
- **性能优化**：使用 Map 快速查找规则
- **去重保护**：避免重复更新

#### 3. 缓存管理
- **容量限制**：最多缓存 10 个规则（约 1.3MB）
- **LRU 策略**：超过容量时，删除最久未使用的规则
- **手动清理**：提供清理按钮，用户可手动清理缓存

#### 4. 降级策略
- **WebSocket 断开**：使用强制重新加载
- **缓存失效**：超过 30 秒未更新，重新加载
- **加载失败**：回退到强制重新加载

---

## 详细实现方案

### 阶段 1：预加载逻辑

**文件**：`App.tsx`

**位置**：WebSocket 连接成功后

```typescript
// 预加载默认规则的数据
const preloadDefaultRules = useCallback(async () => {
  const defaultRules = [
    { id: '1', value: 1, startBlock: 0 },
    { id: '20', value: 20, startBlock: 0 },
    { id: '60', value: 60, startBlock: 0 },
    { id: '100', value: 100, startBlock: 0 },
  ];
  
  console.log('[预加载] 🚀 开始预加载默认规则...');
  const startTime = Date.now();
  
  // 并行加载所有规则
  const promises = defaultRules.map(async (rule) => {
    try {
      const response = await fetch(
        `${BACKEND_API_URL}/api/blocks?limit=264&ruleValue=${rule.value}&startBlock=${rule.startBlock}`
      );
      const result = await response.json();
      
      if (result.success) {
        const cacheKey = `${rule.value}-${rule.startBlock}`;
        return { cacheKey, data: result.data };
      }
    } catch (error) {
      console.error(`[预加载] ❌ 规则 ${rule.id} 加载失败:`, error);
    }
    return null;
  });
  
  const results = await Promise.all(promises);
  
  // 更新缓存
  setBlocksCache(prev => {
    const newCache = new Map(prev);
    const now = Date.now();
    
    results.forEach(result => {
      if (result) {
        newCache.set(result.cacheKey, {
          data: result.data,
          timestamp: now
        });
      }
    });
    
    return newCache;
  });
  
  const endTime = Date.now();
  console.log(`[预加载] ✅ 预加载完成，耗时: ${endTime - startTime}ms`);
  console.log(`[预加载] 📊 已缓存规则数: ${results.filter(r => r).length}`);
}, []);

// WebSocket 连接成功后调用
ws.onopen = () => {
  setWsConnected(true);
  console.log('[连接] ✅ WebSocket 连接成功');
  
  // 预加载默认规则
  preloadDefaultRules();
};
```

### 阶段 2：WebSocket 同步更新

**文件**：`App.tsx`

**位置**：WebSocket `onmessage` 处理函数

```typescript
ws.onmessage = (event) => {
  const block = JSON.parse(event.data);
  
  // 同步更新所有已缓存规则
  setBlocksCache(prevCache => {
    const newCache = new Map(prevCache);
    const now = Date.now();
    let updateCount = 0;
    
    // 遍历所有已缓存的规则
    Array.from(newCache.entries()).forEach(([cacheKey, cacheEntry]) => {
      const [ruleValue, startBlock] = cacheKey.split('-').map(Number);
      
      // 检查新区块是否符合这个规则
      let isAligned = false;
      if (ruleValue <= 1) {
        isAligned = true;
      } else if (startBlock > 0) {
        isAligned = block.height >= startBlock && 
                    (block.height - startBlock) % ruleValue === 0;
      } else {
        isAligned = block.height % ruleValue === 0;
      }
      
      // 如果符合规则，更新缓存
      if (isAligned) {
        const cachedData = cacheEntry.data;
        
        // 去重检查
        if (!cachedData.some(b => b.height === block.height)) {
          const updated = [block, ...cachedData].slice(0, 264);
          newCache.set(cacheKey, {
            data: updated,
            timestamp: now
          });
          updateCount++;
        }
      }
    });
    
    if (updateCount > 0 && process.env.NODE_ENV === 'development') {
      console.log(`[WebSocket] 🔄 同步更新 ${updateCount} 个规则缓存（区块: ${block.height}）`);
    }
    
    return newCache;
  });
  
  // 更新当前激活规则的显示数据
  const currentRule = activeRuleRef.current;
  if (currentRule) {
    const cacheKey = `${currentRule.value}-${currentRule.startBlock}`;
    const cacheEntry = blocksCacheRef.current.get(cacheKey);
    if (cacheEntry) {
      setAllBlocks(cacheEntry.data);
    }
  }
};
```

### 阶段 3：规则切换优化

**文件**：`App.tsx`

**位置**：`loadHistoryBlocks` 函数

```typescript
const loadHistoryBlocks = useCallback(async (forceReload: boolean = false) => {
  try {
    const ruleValue = activeRule?.value || 1;
    const startBlock = activeRule?.startBlock || 0;
    const cacheKey = `${ruleValue}-${startBlock}`;
    
    // 检查缓存
    if (!forceReload && blocksCacheRef.current.has(cacheKey)) {
      const cacheEntry = blocksCacheRef.current.get(cacheKey)!;
      const cacheAge = Date.now() - cacheEntry.timestamp;
      
      // 缓存未过期（30秒）
      if (cacheAge < 30000) {
        console.log(`[缓存] ✅ 使用缓存（0ms），规则: ${activeRule?.label}`);
        setAllBlocks(cacheEntry.data);
        return;
      } else {
        console.log(`[缓存] ⏰ 缓存已过期 (${(cacheAge / 1000).toFixed(1)}秒)，重新加载`);
      }
    }
    
    // 缓存不存在或已过期，从后端加载
    setIsLoading(true);
    console.log(`[API] 🚀 加载规则: ${activeRule?.label}`);
    
    const response = await fetch(
      `${BACKEND_API_URL}/api/blocks?limit=264&ruleValue=${ruleValue}&startBlock=${startBlock}`
    );
    const result = await response.json();
    
    if (result.success) {
      setAllBlocks(result.data);
      
      // 更新缓存
      setBlocksCache(prev => {
        const newCache = new Map(prev);
        newCache.set(cacheKey, {
          data: result.data,
          timestamp: Date.now()
        });
        
        // LRU 策略：限制缓存大小
        if (newCache.size > 10) {
          const firstKey = newCache.keys().next().value;
          newCache.delete(firstKey);
          console.log(`[缓存] 🗑️ 删除最旧的缓存: ${firstKey}`);
        }
        
        return newCache;
      });
      
      console.log(`[API] ✅ 加载完成: ${result.data.length} 条`);
    }
    
    setIsLoading(false);
  } catch (error) {
    console.error('[API] 加载失败:', error);
    setIsLoading(false);
  }
}, [activeRule]);
```

### 阶段 4：规则切换逻辑

**文件**：`App.tsx`

**位置**：规则切换 useEffect

```typescript
// 规则变化时智能加载数据
useEffect(() => {
  if (!wsConnected || !activeRule) return;
  
  console.log(`[规则变化] 切换到规则: ${activeRule.label}`);
  loadHistoryBlocks(false);  // 优先使用缓存
}, [activeRuleId, wsConnected, loadHistoryBlocks]);
```

---

## 性能预估

### 首次加载
- **预加载 4 个规则**：并行加载，约 50-70ms
- **用户感知**：几乎无感知（后台加载）

### 规则切换
- **缓存命中**：0ms ✅
- **缓存未命中**：35-110ms（首次使用新规则）

### WebSocket 同步
- **每个新区块**：约 1ms（检查 4-10 个规则）
- **性能影响**：可忽略

### 内存占用
- **4 个默认规则**：1056 条 × 0.5KB = 0.5MB
- **10 个规则上限**：2640 条 × 0.5KB = 1.3MB
- **结论**：完全可接受

---

## 其他推荐方案

### 方案 A：IndexedDB 持久化缓存

**思路**：将缓存存储到 IndexedDB，刷新页面后仍然可用

**优势**：
- 刷新页面后无需重新加载
- 可存储更多数据（几十 MB）
- 离线可用

**劣势**：
- 实现复杂度高
- 需要处理数据同步问题
- 可能出现缓存过期问题

**适用场景**：需要离线支持的应用

### 方案 B：Service Worker 缓存

**思路**：使用 Service Worker 拦截 API 请求，缓存响应

**优势**：
- 自动缓存管理
- 离线支持
- 透明缓存

**劣势**：
- 实现复杂度高
- 调试困难
- 需要处理缓存更新策略

**适用场景**：PWA 应用

### 方案 C：后端 Redis 缓存

**思路**：后端 Redis 缓存过滤后的数据，减少计算

**优势**：
- 后端性能提升
- 减少数据库查询
- 多用户共享缓存

**劣势**：
- 需要修改后端
- 缓存失效策略复杂
- 内存占用增加

**适用场景**：高并发场景

---

## 最终推荐

### 🏆 推荐方案：多规则预加载缓存（增强版）

**理由**：
1. **性能最优**：规则切换 0ms
2. **数据准确**：WebSocket 同步更新，无断层
3. **内存可控**：约 0.5-1.3MB，完全可接受
4. **实现难度**：中等，可在 1-2 小时内完成
5. **用户体验**：最佳，无感知切换

**实施优先级**：
1. ✅ **立即实施**：多规则预加载缓存
2. 🔄 **后续优化**：IndexedDB 持久化（可选）
3. 🔄 **长期优化**：后端 Redis 缓存（可选）

---

## 实施计划

### 第 1 步：后端修改（无需修改）
- 现有 API 已支持按规则过滤
- 前端并行请求即可

### 第 2 步：前端修改（1-2 小时）
1. 添加预加载逻辑（20 行）
2. 修改 WebSocket 同步逻辑（30 行）
3. 修改规则切换逻辑（5 行）
4. 添加缓存管理逻辑（20 行）

### 第 3 步：测试验证（30 分钟）
1. 测试预加载
2. 测试 WebSocket 同步
3. 测试规则切换
4. 测试内存占用

### 第 4 步：上线部署（10 分钟）
1. 合并代码
2. 部署前端
3. 监控性能

---

## 总结

你提出的"多规则预加载缓存"方案是目前最优的解决方案：

✅ **性能**：规则切换 0ms，用户无感知  
✅ **准确性**：WebSocket 同步更新，数据始终完整  
✅ **内存**：约 0.5-1.3MB，完全可接受  
✅ **难度**：中等，1-2 小时可完成  
✅ **体验**：最佳，无感知切换  

**建议立即实施这个方案！**
