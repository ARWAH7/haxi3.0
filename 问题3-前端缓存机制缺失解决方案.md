# 问题 3：前端没有缓存机制 - 解决方案

## 📋 问题描述

### 问题表现
前端只保存当前规则的数据，切换规则时，旧规则的数据被丢弃，切换回旧规则时需要重新加载数据。

### 问题位置
**文件**：`App.tsx` - 数据管理

```typescript
const [allBlocks, setAllBlocks] = useState<BlockData[]>([]);
```

### 问题分析

#### 1. 单一数据存储
- **只有一个状态**：`allBlocks` 只存储当前规则的数据
- **切换即丢弃**：切换到新规则时，旧规则的数据被覆盖
- **无法复用**：切换回旧规则时，需要重新加载数据

#### 2. 用户场景分析

**场景 1：频繁切换规则**
```
用户操作：规则 A → 规则 B → 规则 A → 规则 B
数据加载：加载 A → 加载 B → 加载 A → 加载 B
问题：每次切换都要重新加载，体验差
```

**场景 2：对比不同规则**
```
用户操作：规则 A → 规则 B → 规则 C → 规则 A
数据加载：加载 A → 加载 B → 加载 C → 加载 A
问题：重复加载相同的数据，浪费资源
```

**场景 3：探索性浏览**
```
用户操作：快速切换多个规则，寻找感兴趣的模式
数据加载：每次切换都要等待加载
问题：加载延迟影响探索体验
```

#### 3. 资源浪费
- **网络带宽**：重复请求相同的数据
- **服务器资源**：重复处理相同的请求
- **用户时间**：每次切换都要等待 ~500ms

---

## 🔧 解决方案

### 方案概述
**核心思路**：实现多规则数据缓存机制，为每个规则单独缓存数据，切换规则时优先使用缓存。

### 缓存设计

#### 1. 数据结构选择

**使用 Map 数据结构**：
```typescript
const [blocksCache, setBlocksCache] = useState<Map<string, BlockData[]>>(new Map());
```

**为什么选择 Map？**
- **键值对存储**：适合存储多个规则的数据
- **快速查找**：O(1) 时间复杂度
- **易于管理**：支持 has、get、set、delete 等操作
- **类型安全**：TypeScript 支持泛型

**对比其他方案**：
| 方案 | 优点 | 缺点 |
|------|------|------|
| Map | 快速查找，易于管理 | 需要手动管理大小 |
| Object | 简单直观 | 键只能是字符串，性能略差 |
| Array | 简单 | 查找慢（O(n)），不适合 |

#### 2. 缓存键设计

**缓存键格式**：`${ruleValue}-${startBlock}`

**示例**：
```typescript
// 规则 "单区块"（步长 1，偏移 0）
cacheKey = "1-0"

// 规则 "20区块"（步长 20，偏移 0）
cacheKey = "20-0"

// 规则 "60区块"（步长 60，偏移 100）
cacheKey = "60-100"
```

**为什么这样设计？**
- **唯一性**：不同的步长和偏移组合生成不同的键
- **简洁性**：键名简短，易于调试
- **可读性**：一眼就能看出是哪个规则

#### 3. 缓存值设计

**缓存值**：`BlockData[]`（区块数据数组）

**数据特点**：
- **已过滤**：只包含符合规则步长的区块
- **已排序**：按 height 降序排列（最新的在前）
- **固定大小**：最多 264 条数据
- **自动更新**：有新数据时，删除最旧的数据，保持 264 条

**缓存规则**：
1. ✅ **只缓存符合规则的数据**：不符合规则步长的区块不会被缓存
2. ✅ **固定容量**：每个规则缓存固定 264 条数据
3. ✅ **FIFO 更新**：新数据到达时，删除最旧的数据
4. ✅ **实时同步**：WebSocket 接收新区块时，实时更新缓存

**示例**：
```typescript
// 3秒规则（步长 1）的缓存
blocksCache.get("1-0") = [
  { height: 1000, ... },  // 最新
  { height: 999, ... },
  { height: 998, ... },
  // ... 共 264 条符合步长 1 的数据
  { height: 737, ... }    // 最旧
]

// 1分钟规则（步长 20）的缓存
blocksCache.get("20-0") = [
  { height: 1000, ... },  // 最新（1000 % 20 === 0）
  { height: 980, ... },   // 980 % 20 === 0
  { height: 960, ... },   // 960 % 20 === 0
  // ... 共 264 条符合步长 20 的数据
  { height: 740, ... }    // 最旧（740 % 20 === 0）
]
```

---

### 实施步骤

#### 步骤 1：添加缓存状态

在 `App.tsx` 中添加缓存状态：

```typescript
// 数据缓存：key 为 "步长-偏移"，value 为该规则的区块数据
const [blocksCache, setBlocksCache] = useState<Map<string, BlockData[]>>(new Map());
```

---

#### 步骤 2：实现缓存读取逻辑

在 `loadHistoryBlocks` 函数中添加缓存读取：

```typescript
const loadHistoryBlocks = useCallback(async (forceReload: boolean = false) => {
  try {
    const ruleValue = activeRule?.value || 1;
    const startBlock = activeRule?.startBlock || 0;
    const requiredFiltered = requiredDataCount;
    const cacheKey = `${ruleValue}-${startBlock}`;
    
    // ✅ 步骤 1：检查缓存是否存在
    if (!forceReload && blocksCache.has(cacheKey)) {
      const cachedData = blocksCache.get(cacheKey)!;
      
      // ✅ 步骤 2：检查缓存数据是否充足
      if (cachedData.length >= requiredFiltered * 0.9) {
        console.log(`[缓存] ✅ 使用缓存数据: ${cachedData.length} 条 (规则: ${activeRule?.label})`);
        
        // ✅ 步骤 3：使用缓存数据
        setAllBlocks(cachedData);
        setIsLoading(false);
        return;  // 直接返回，不进行网络请求
      } else {
        console.log(`[缓存] ⚠️ 缓存数据不足: ${cachedData.length} 条，需要: ${requiredFiltered} 条`);
      }
    } else {
      console.log(`[缓存] ❌ 缓存未命中: ${cacheKey}`);
    }
    
    // ✅ 缓存未命中或数据不足，从后端加载
    setIsLoading(true);
    // ... 后续的加载逻辑 ...
  } catch (error) {
    console.error('[API] 加载历史数据失败:', error);
    setIsLoading(false);
  }
}, [activeRule, requiredDataCount, blocksCache]);
```

**关键点**：
1. **缓存检查**：使用 `blocksCache.has(cacheKey)` 检查缓存是否存在
2. **数据充足性检查**：确保缓存数据量 >= 需求量的 90%
3. **快速返回**：缓存命中时，直接返回，不进行网络请求

---

#### 步骤 3：实现缓存写入逻辑

在数据加载成功后，将数据写入缓存：

```typescript
if (result.success) {
  // ✅ 步骤 1：更新当前数据
  setAllBlocks(result.data);
  
  // ✅ 步骤 2：写入缓存
  setBlocksCache(prev => {
    const newCache = new Map(prev);
    newCache.set(cacheKey, result.data);
    
    // ✅ 步骤 3：限制缓存大小（最多保留 10 个规则）
    if (newCache.size > 10) {
      const firstKey = newCache.keys().next().value;
      newCache.delete(firstKey);
      console.log(`[缓存] 🗑️ 删除最旧的缓存: ${firstKey}`);
    }
    
    return newCache;
  });
  
  console.log(`[API] ✅ 后端过滤完成: 返回 ${result.data.length} 条数据`);
  console.log(`[缓存] 💾 已缓存规则: ${cacheKey}`);
}
```

**关键点**：
1. **不可变更新**：使用 `new Map(prev)` 创建新的 Map
2. **缓存大小限制**：最多保留 10 个规则的缓存
3. **FIFO 策略**：删除最早添加的缓存

---

#### 步骤 4：实现缓存同步逻辑

在 WebSocket 接收新区块后，同步更新缓存：

```typescript
setAllBlocks(prev => {
  // ... 现有的数据更新逻辑 ...
  
  // ✅ 同步更新缓存
  if (currentRule) {
    const cacheKey = `${currentRule.value}-${currentRule.startBlock}`;
    setBlocksCache(prevCache => {
      const newCache = new Map(prevCache);
      newCache.set(cacheKey, updated);
      return newCache;
    });
    
    if (process.env.NODE_ENV === 'development') {
      console.log(`[缓存] 💾 已同步缓存: ${cacheKey}`);
    }
  }
  
  return updated;
});
```

**关键点**：
- **实时同步**：WebSocket 更新数据时，同步更新缓存
- **保持一致性**：确保缓存数据始终是最新的

---

#### 步骤 5：修改规则切换逻辑

修改规则变化时的加载逻辑，优先使用缓存：

```typescript
// 规则变化时检查是否需要重新加载数据
useEffect(() => {
  if (!wsConnected || !activeRule) return;
  
  // ✅ 不使用防抖，立即切换
  // 因为有缓存机制，切换速度很快
  console.log(`[规则变化] 切换到规则: ${activeRule.label} (步长 ${activeRule.value})`);
  loadHistoryBlocks(false);  // ✅ 不强制重新加载，优先使用缓存
}, [activeRuleId, wsConnected, loadHistoryBlocks]);
```

**关键点**：
- **移除防抖**：缓存命中时切换很快，不需要防抖
- **不强制重新加载**：让 `loadHistoryBlocks` 自己决定是否使用缓存

---

## 📊 缓存效果分析

### 缓存命中率

**理想情况**（用户在 5 个规则之间切换）：
```
第 1 次切换：缓存未命中，加载数据，写入缓存
第 2 次切换：缓存未命中，加载数据，写入缓存
第 3 次切换：缓存未命中，加载数据，写入缓存
第 4 次切换：缓存未命中，加载数据，写入缓存
第 5 次切换：缓存未命中，加载数据，写入缓存
第 6 次切换：缓存命中！（切换回第 1 个规则）
第 7 次切换：缓存命中！（切换回第 2 个规则）
...

缓存命中率：随着使用时间增加，逐渐接近 100%
```

**实际情况**（用户主要使用 2-3 个规则）：
```
常用规则：规则 A、规则 B
偶尔使用：规则 C、规则 D

缓存命中率：约 80-90%
```

### 性能提升

| 场景 | 修复前 | 修复后 | 提升 |
|------|--------|--------|------|
| 首次切换到规则 A | 500ms | 500ms | 无变化 |
| 切换回规则 A（缓存命中） | 500ms | 10ms | 50 倍 ↑ |
| 频繁切换 2 个规则 | 500ms × N | 10ms × N | 50 倍 ↑ |
| 探索 10 个规则 | 500ms × 10 | 500ms × 10 + 10ms × N | 后续切换快 |

### 内存占用

**单个规则的内存占用**：
- 264 条区块数据
- 每条区块约 0.5KB
- 单个规则约 132KB

**10 个规则的内存占用**：
- 10 × 132KB = 1.32MB
- 对于现代浏览器来说，这是可接受的

**内存占用监控**：
```typescript
// 在开发模式下监控缓存大小
if (process.env.NODE_ENV === 'development') {
  console.log(`[缓存] 📊 缓存统计: ${blocksCache.size} 个规则`);
  console.log(`[缓存] 💾 估算内存占用: ${(blocksCache.size * 132).toFixed(0)} KB`);
}
```

---

## ⚠️ 注意事项

### 1. 缓存大小限制

**为什么限制为 10 个？**
- **内存考虑**：10 个规则约 1.32MB，可接受
- **实际需求**：大多数用户只使用 2-5 个规则
- **性能平衡**：太多缓存会影响内存性能

**如何调整限制？**
```typescript
// 修改缓存大小限制
const MAX_CACHE_SIZE = 10;  // 可以根据需要调整

if (newCache.size > MAX_CACHE_SIZE) {
  const firstKey = newCache.keys().next().value;
  newCache.delete(firstKey);
}
```

### 2. 缓存清理策略

**当前策略：FIFO（先进先出）**
```typescript
// 删除最早添加的缓存
const firstKey = newCache.keys().next().value;
newCache.delete(firstKey);
```

**其他可选策略**：

**LRU（最近最少使用）**：
```typescript
// 需要额外维护访问时间
const cacheWithTimestamp = new Map<string, { data: BlockData[], lastAccess: number }>();

// 删除最久未使用的缓存
let oldestKey = '';
let oldestTime = Infinity;
for (const [key, value] of newCache.entries()) {
  if (value.lastAccess < oldestTime) {
    oldestTime = value.lastAccess;
    oldestKey = key;
  }
}
newCache.delete(oldestKey);
```

**LFU（最不经常使用）**：
```typescript
// 需要额外维护访问次数
const cacheWithCount = new Map<string, { data: BlockData[], accessCount: number }>();

// 删除访问次数最少的缓存
let leastUsedKey = '';
let leastCount = Infinity;
for (const [key, value] of newCache.entries()) {
  if (value.accessCount < leastCount) {
    leastCount = value.accessCount;
    leastUsedKey = key;
  }
}
newCache.delete(leastUsedKey);
```

**推荐**：对于当前场景，FIFO 策略已经足够，因为：
- 实现简单
- 性能开销小
- 大多数用户的使用模式相对固定

### 3. 缓存失效

**问题**：什么时候缓存会失效？

**场景 1：WebSocket 接收新区块**
- **解决方案**：实时同步更新缓存
- **实现**：在 WebSocket 数据更新时，同步更新缓存

**场景 2：用户手动刷新**
- **解决方案**：提供手动清除缓存的功能
- **实现**：
  ```typescript
  const clearCache = () => {
    setBlocksCache(new Map());
    console.log('[缓存] 🗑️ 已清除所有缓存');
  };
  ```

**场景 3：规则配置变化**
- **解决方案**：规则配置变化时，清除相关缓存
- **实现**：
  ```typescript
  useEffect(() => {
    // 规则配置变化时，清除所有缓存
    setBlocksCache(new Map());
    console.log('[缓存] 🗑️ 规则配置变化，清除所有缓存');
  }, [rules]);
  ```

### 4. 缓存数据充足性检查

**为什么使用 90% 阈值？**
```typescript
if (cachedData.length >= requiredFiltered * 0.9) {
  // 使用缓存
}
```

**原因**：
- **容错性**：允许缓存数据略少于需求
- **避免频繁加载**：避免因为少几条数据就重新加载
- **用户体验**：少几条数据对用户体验影响不大

**可调整**：
```typescript
const CACHE_THRESHOLD = 0.9;  // 90% 阈值，可以调整

if (cachedData.length >= requiredFiltered * CACHE_THRESHOLD) {
  // 使用缓存
}
```

---

## 🚀 实施建议

### 优先级：高

**原因**：
1. **用户体验影响最大**：切换规则几乎无延迟
2. **实施简单**：只需添加一个状态和几个逻辑
3. **风险低**：不影响现有功能
4. **性能提升明显**：50 倍性能提升

### 实施顺序

1. **第一步**：添加 `blocksCache` 状态
2. **第二步**：实现缓存读取逻辑
3. **第三步**：实现缓存写入逻辑
4. **第四步**：实现缓存同步逻辑
5. **第五步**：修改规则切换逻辑
6. **第六步**：测试缓存功能

### 测试要点

1. **缓存命中测试**：
   ```
   操作：规则 A → 规则 B → 规则 A
   验证：第二次切换到规则 A 时，使用缓存数据（~10ms）
   ```

2. **缓存更新测试**：
   ```
   操作：规则 A → WebSocket 接收新区块 → 规则 B → 规则 A
   验证：规则 A 的缓存包含新区块
   ```

3. **缓存限制测试**：
   ```
   操作：连续切换 15 个不同的规则
   验证：缓存大小不超过 10 个
   ```

4. **内存占用测试**：
   ```
   工具：Chrome DevTools → Memory Profiler
   验证：缓存占用内存 < 2MB
   ```

5. **缓存清理测试**：
   ```
   操作：切换 11 个规则
   验证：第 1 个规则的缓存被删除
   ```

---

## 📈 缓存监控

### 监控指标

1. **缓存命中率**：
   ```typescript
   let cacheHits = 0;
   let cacheMisses = 0;
   
   // 在 loadHistoryBlocks 中统计
   if (blocksCache.has(cacheKey)) {
     cacheHits++;
     console.log(`[缓存] 📊 命中率: ${(cacheHits / (cacheHits + cacheMisses) * 100).toFixed(1)}%`);
   } else {
     cacheMisses++;
   }
   ```

2. **缓存大小**：
   ```typescript
   console.log(`[缓存] 📊 缓存统计: ${blocksCache.size} 个规则`);
   ```

3. **内存占用**：
   ```typescript
   const estimatedMemory = blocksCache.size * 132;  // KB
   console.log(`[缓存] 💾 估算内存占用: ${estimatedMemory.toFixed(0)} KB`);
   ```

4. **缓存键列表**：
   ```typescript
   const cacheKeys = Array.from(blocksCache.keys());
   console.log(`[缓存] 🔑 缓存键列表:`, cacheKeys);
   ```

---

## 📝 总结

### 问题根源
前端只保存当前规则的数据，切换规则时旧数据被丢弃，无法复用已加载的数据。

### 解决方案
实现多规则数据缓存机制，为每个规则单独缓存数据，切换规则时优先使用缓存。

### 预期效果
- **缓存命中时**：50 倍性能提升（500ms → 10ms）
- **用户体验**：切换规则几乎无延迟
- **资源节省**：减少不必要的网络请求和服务器负载
- **内存占用**：约 1.32MB（10 个规则），可接受

### 适用场景
- 用户频繁切换规则
- 用户对比不同规则
- 用户探索性浏览

---

**文档创建时间**：2026-02-07  
**文档版本**：1.0
