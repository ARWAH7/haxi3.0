# 珠盘路显示问题修复完成

## ✅ 修复内容

### 1. 修改 `utils/helpers.ts` - calculateBeadGrid 函数

**修复前**：使用数组索引计算位置
```typescript
displayBlocks.forEach((block, idx) => {
  const col = Math.floor(idx / validRows);  // ❌ 数组索引
  const row = idx % validRows;
});
```

**修复后**：使用全局索引系统
```typescript
const indexedBlocks = chronological.map(b => ({
  block: b,
  idx: Math.floor((b.height - epoch) / validInterval)  // ✅ 全局索引
}));

indexedBlocks.forEach(({ block, idx }) => {
  const globalCol = Math.floor(idx / validRows);
  const localCol = globalCol - adjustedStartColIdx;
  const localRow = idx % validRows;
  // ... 填充网格
});
```

**关键改进**：
- 区块位置由其高度决定，不受数组变化影响
- 实现滑动窗口，只显示最新的 44 列
- 自动实现"列填满后移到下一列第一行"的效果

### 2. 修改 `App.tsx` - WebSocket 数据管理

**修复前**：允许数据达到 265 条，然后删除 6 条
```typescript
if (sorted.length >= MAX_BLOCKS_CAPACITY) {
  const deleteCount = ROWS;  // 删除6条
  updated = sorted.slice(0, sorted.length - deleteCount);
}
```

**修复后**：永远保持 264 条
```typescript
if (sorted.length > MAX_BLOCKS_CAPACITY) {
  updated = sorted.slice(0, MAX_BLOCKS_CAPACITY);  // ✅ 只保留最新的 264 条
}
```

**关键改进**：
- 数据量永远不超过 264 条
- 配合全局索引系统，实现稳定的显示效果

## 🎯 修复效果

### 场景：区块 400 在最右最下，新区块 401-402 到达

**修复前（错误）**：
```
区块 400 在 列43行5（最右最下）
新区块 401 到达
↓ 删除 6 条最旧的数据
❌ 区块 400 跳到 列43行4
❌ 区块 401 在 列43行5
```

**修复后（正确）**：
```
区块 400 在 列43行5（最右最下）
新区块 401 到达
↓ 删除 1 条最旧的数据
✅ 区块 400 保持在 列43行4（全局列66行4）
✅ 区块 401 在 列43行5（全局列66行5）

新区块 402 到达
↓ 删除 1 条最旧的数据
✅ 区块 402 在 列43行0（全局列67行0）✅ 新列的第一行！
```

### 全局索引计算示例

```
区块 400: 全局索引 = 400, 全局列 = 400/6 = 66, 全局行 = 400%6 = 4
区块 401: 全局索引 = 401, 全局列 = 401/6 = 66, 全局行 = 401%6 = 5
区块 402: 全局索引 = 402, 全局列 = 402/6 = 67, 全局行 = 402%6 = 0 ✅
```

**关键发现**：
- 当一列填满（6个单元格），下一个区块自动进入下一列的第一行（行0）
- 这是由全局索引系统自动实现的，不需要额外的逻辑

## 📊 测试验证

运行测试文件 `test-bead-grid-fix.js`：

```bash
node test-bead-grid-fix.js
```

**测试结果**：
```
场景 1：264 条数据（区块 137-400）
  区块 400: 全局索引 400, 全局列 66, 全局行 4

场景 2：新区块 401 到达
  区块 401: 全局索引 401, 全局列 66, 全局行 5

场景 3：新区块 402 到达
  区块 402: 全局索引 402, 全局列 67, 全局行 0 ✅ 新列的第一行！
```

✅ 测试通过！全局索引系统正确实现了预期效果。

## 🔍 调试日志

修复后的代码包含详细的调试日志，可以在浏览器控制台查看：

```javascript
// calculateBeadGrid 函数
[BeadGrid] 全局索引计算:
  区块 137: 全局索引 137, 全局列 22, 全局行 5
  区块 138: 全局索引 138, 全局列 23, 全局行 0
  ...
  区块 400: 全局索引 400, 全局列 66, 全局行 4

[BeadGrid] 窗口信息:
  总列数: 45, 实际列数: 44
  起始列索引: 23, 结束列索引: 66
  显示区块: 137 - 400

// App.tsx WebSocket
[WebSocket] 🔄 数据超过容量: 265 条，截取最新的 264 条
[WebSocket] 🗑️ 删除区块: 137 - 137
[WebSocket] 📊 保留数据: 264 条 (138 - 401)
```

## ⚠️ 注意事项

1. **数据排序**：
   - calculateBeadGrid 内部会将数据从旧到新排序
   - App.tsx 中的数据按高度降序排列（最新的在前）

2. **步长和偏移**：
   - 步长（interval）：每隔多少个区块采样一次
   - 偏移（startBlock）：从哪个区块高度开始采样
   - 全局索引 = (区块高度 - 偏移) / 步长

3. **列数限制**：
   - 固定显示 44 列
   - 超过 44 列时，只显示最新的 44 列
   - 自动滑动窗口

4. **性能优化**：
   - 全局索引计算只在数据变化时执行
   - 使用 useMemo 缓存计算结果
   - 避免不必要的重新渲染

## 🚀 下一步

1. **启动开发服务器**：
   ```bash
   npm run dev
   ```

2. **启动后端服务**：
   ```bash
   cd backend
   npm run dev
   ```

3. **验证修复效果**：
   - 打开浏览器控制台
   - 观察珠盘路显示
   - 等待新区块到达
   - 验证区块位置是否稳定
   - 验证新区块是否出现在正确的位置

4. **切换规则测试**：
   - 切换不同的规则（单区块、20区块、60区块等）
   - 验证珠盘路是否正确更新
   - 验证数据是否符合规则

## ✅ 预期成果

修复完成后，珠盘路应该：

1. **位置稳定**：区块位置不会跳动
2. **自动滑动**：新数据到达时自动滚动到最右侧
3. **容量限制**：始终保持 264 条数据
4. **性能良好**：渲染流畅，无卡顿
5. **规则切换**：切换规则后立即更新显示
6. **正确填充**：当一列填满后，下一个区块出现在下一列的第一行

---

**修复完成时间**：2026-02-07  
**修复文件**：
- `utils/helpers.ts` (calculateBeadGrid 函数)
- `App.tsx` (WebSocket 数据管理)
- `test-bead-grid-fix.js` (测试验证)
