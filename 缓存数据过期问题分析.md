# 缓存数据过期问题分析

## 问题现象
- 切换到 3秒（步长1）规则时，数据显示 79928321
- 实际 Redis 中最新数据是 79928324
- 刷新网页后显示正常（79928324）

## 根本原因

### 问题1：缓存没有过期机制
当前实现中，缓存一旦建立就永久有效，不会自动更新：

```typescript
// 当前实现
if (!forceReload && blocksCacheRef.current.has(cacheKey)) {
  const cachedData = blocksCacheRef.current.get(cacheKey)!;
  // ❌ 直接使用缓存，不检查是否过期
  setAllBlocks(cachedData);
  return;
}
```

### 问题2：WebSocket 只更新当前激活规则的缓存
当用户在规则 A 时，WebSocket 推送的新区块只会更新规则 A 的缓存。切换到规则 B 后，规则 B 的缓存仍然是旧数据。

```typescript
// WebSocket 消息处理
if (currentRule) {
  const cacheKey = `${currentRule.value}-${currentRule.startBlock}`;
  setBlocksCache(prevCache => {
    const newCache = new Map(prevCache);
    newCache.set(cacheKey, updated);  // ❌ 只更新当前规则的缓存
    return newCache;
  });
}
```

### 问题3：规则切换时没有验证缓存新鲜度
切换规则时，没有检查缓存数据是否是最新的：

```typescript
// 规则切换时
loadHistoryBlocks(false);  // ❌ forceReload=false，优先使用缓存
```

## 解决方案

### 方案1：添加缓存时间戳（推荐）✅
为每个缓存条目添加时间戳，超过一定时间后重新加载：

```typescript
interface CacheEntry {
  data: BlockData[];
  timestamp: number;
}

const CACHE_TTL = 30000; // 30秒过期

// 检查缓存是否过期
const isCacheValid = (entry: CacheEntry) => {
  return Date.now() - entry.timestamp < CACHE_TTL;
};
```

### 方案2：WebSocket 推送时更新所有规则的缓存（推荐）✅
当 WebSocket 推送新区块时，更新所有符合条件的规则缓存：

```typescript
// 更新所有规则的缓存
blocksCacheRef.current.forEach((cachedData, cacheKey) => {
  const [ruleValue, startBlock] = cacheKey.split('-').map(Number);
  
  // 检查新区块是否符合这个规则
  if (isBlockAlignedWithRule(block, ruleValue, startBlock)) {
    // 更新这个规则的缓存
    const updated = [block, ...cachedData].slice(0, 264);
    blocksCacheRef.current.set(cacheKey, updated);
  }
});
```

### 方案3：规则切换时强制验证缓存（可选）
切换规则时，总是从后端获取最新的区块高度，对比缓存：

```typescript
// 获取最新区块高度
const latestHeight = await fetchLatestBlockHeight();

// 对比缓存
if (cachedData[0]?.height < latestHeight) {
  // 缓存过期，重新加载
  loadHistoryBlocks(true);
}
```

## 推荐实施方案

**组合方案：方案1 + 方案2**

1. **添加缓存时间戳**（30秒过期）
   - 简单有效
   - 避免使用过期数据
   - 性能影响小

2. **WebSocket 推送时更新所有规则缓存**
   - 保持所有缓存最新
   - 避免规则切换时数据跳跃
   - 实时性好

## 实施优先级

1. **立即实施**：方案2（WebSocket 更新所有规则缓存）
   - 解决数据跳跃问题
   - 保持缓存实时性

2. **短期实施**：方案1（缓存时间戳）
   - 作为兜底机制
   - 防止长时间未切换导致的数据过期

3. **长期优化**：方案3（强制验证）
   - 作为可选的严格模式
   - 适用于对数据准确性要求极高的场景
