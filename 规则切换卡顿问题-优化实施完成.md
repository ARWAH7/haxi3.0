# 规则切换卡顿问题 - 优化实施完成

## 📋 实施总结

**实施时间**：2026-02-07  
**实施状态**：✅ 完成

---

## 🎯 实施的优化方案

### 核心思路

**前端缓存 + 后端动态加载 = 最优性能**

---

## ✅ 已完成的修改

### 阶段1：前端缓存机制（优先级：高）

#### 1.1 添加缓存状态和 ref

**文件**：`App.tsx`

**修改位置**：状态声明部分（第 95-103 行）

```typescript
// ✅ 阶段1：添加前端缓存状态
const [blocksCache, setBlocksCache] = useState<Map<string, BlockData[]>>(new Map());

const blocksRef = useRef<BlockData[]>([]);
const isPollingBusy = useRef(false);
const navRef = useRef<HTMLDivElement>(null);
const activeRuleRef = useRef<IntervalRule | undefined>(undefined);
const blocksCacheRef = useRef(new Map<string, BlockData[]>());  // ✅ 阶段3：添加缓存 ref
```

**功能**：
- 添加 `blocksCache` 状态用于存储每个规则的缓存数据
- 添加 `blocksCacheRef` 用于在 useCallback 中访问最新的缓存状态

---

#### 1.2 同步更新 blocksCacheRef

**文件**：`App.tsx`

**修改位置**：useEffect 部分（第 265-269 行）

```typescript
// ✅ 阶段3：同步更新 blocksCacheRef
useEffect(() => {
  blocksCacheRef.current = blocksCache;
}, [blocksCache]);
```

**功能**：
- 确保 `blocksCacheRef` 始终指向最新的缓存数据
- 避免闭包问题

---

#### 1.3 修改 loadHistoryBlocks 函数

**文件**：`App.tsx`

**修改位置**：loadHistoryBlocks 函数（第 347-410 行）

**核心改动**：

1. **添加缓存检查逻辑**：
```typescript
const cacheKey = `${ruleValue}-${startBlock}`;

// ✅ 优先使用缓存数据
if (!forceReload && blocksCacheRef.current.has(cacheKey)) {
  const cachedData = blocksCacheRef.current.get(cacheKey)!;
  if (cachedData.length >= requiredFiltered * 0.9) {
    console.log(`[缓存] ✅ 使用缓存数据: ${cachedData.length} 条 (规则: ${activeRule?.label})`);
    setAllBlocks(cachedData);
    setIsLoading(false);
    return;  // 🚀 缓存命中，直接返回，不进行网络请求
  }
}
```

2. **添加缓存更新逻辑**：
```typescript
// ✅ 更新缓存
setBlocksCache(prev => {
  const newCache = new Map(prev);
  newCache.set(cacheKey, result.data);
  
  // ✅ 及时清理：限制缓存大小（最多保留 10 个规则）
  if (newCache.size > 10) {
    const firstKey = newCache.keys().next().value;
    newCache.delete(firstKey);
    console.log(`[缓存] 🗑️ 删除最旧的缓存: ${firstKey}`);
    console.log(`[缓存] 📊 当前缓存: ${newCache.size} 个规则`);
  }
  
  return newCache;
});
```

**功能**：
- 缓存命中时，直接使用缓存数据，不进行网络请求（~10ms）
- 缓存未命中时，从后端加载数据并更新缓存
- 自动清理：最多保留 10 个规则的缓存（FIFO 策略）

---

#### 1.4 修改规则切换逻辑

**文件**：`App.tsx`

**修改位置**：规则变化 useEffect（第 412-417 行）

**修改前**：
```typescript
// 使用防抖避免频繁切换时重复加载
const timer = setTimeout(() => {
  console.log(`[规则变化] 切换到规则: ${activeRule.label} (步长 ${activeRule.value})，强制重新加载数据`);
  loadHistoryBlocks(true);  // 强制重新加载
}, 300);
```

**修改后**：
```typescript
// ✅ 立即切换，不使用防抖（因为有缓存，切换很快）
console.log(`[规则变化] 切换到规则: ${activeRule.label}`);
loadHistoryBlocks(false);  // ✅ 不强制重新加载，优先使用缓存
```

**功能**：
- 移除防抖延迟，立即切换规则
- 不强制重新加载，优先使用缓存
- 缓存命中时，切换几乎无延迟

---

#### 1.5 WebSocket 数据更新时同步缓存

**文件**：`App.tsx`

**修改位置**：WebSocket onmessage 处理（第 580-595 行）

**添加的代码**：
```typescript
// ✅ 阶段1：同步更新缓存
if (currentRule) {
  const cacheKey = `${currentRule.value}-${currentRule.startBlock}`;
  setBlocksCache(prevCache => {
    const newCache = new Map(prevCache);
    newCache.set(cacheKey, updated);  // 缓存符合规则的264条最新数据
    
    // ✅ 及时清理：限制缓存大小（最多保留 10 个规则）
    if (newCache.size > 10) {
      const firstKey = newCache.keys().next().value;
      newCache.delete(firstKey);
      if (process.env.NODE_ENV === 'development') {
        console.log(`[缓存] 🗑️ WebSocket更新时删除最旧的缓存: ${firstKey}`);
      }
    }
    
    return newCache;
  });
}
```

**功能**：
- WebSocket 接收到新区块时，同步更新缓存
- 确保缓存数据始终是最新的
- 自动清理超过限制的缓存

---

### 阶段2：后端动态加载（优先级：高）

#### 2.1 修改 /api/blocks 端点

**文件**：`backend/src/api.ts`

**修改位置**：/api/blocks 路由（第 24-95 行）

**核心改动**：

1. **动态计算需要加载的数据量**：
```typescript
// ✅ 阶段2：动态计算需要加载的原始数据量
const safetyFactor = 1.5;
const estimatedRawBlocks = Math.ceil(limit * ruleValue * safetyFactor);
const MAX_RAW_BLOCKS = Math.min(estimatedRawBlocks, 30000);
```

2. **添加性能监控**：
```typescript
// ✅ 性能监控
const startTime = Date.now();

// 1. 从 Redis 加载动态计算的数据量
const allBlocks = await getBlocks(MAX_RAW_BLOCKS);
const loadTime = Date.now();

// 2. 在内存中快速过滤
let filteredBlocks = allBlocks;
if (ruleValue > 1) {
  filteredBlocks = allBlocks.filter(block => {
    if (startBlock > 0) {
      return block.height >= startBlock && (block.height - startBlock) % ruleValue === 0;
    }
    return block.height % ruleValue === 0;
  });
}
const filterTime = Date.now();

// 3. 返回前 N 条数据
const resultBlocks = filteredBlocks.slice(0, limit);
const endTime = Date.now();
```

3. **输出性能统计**：
```typescript
console.log(`[API] ⏱️ 性能统计:`);
console.log(`  - Redis 加载: ${loadTime - startTime}ms`);
console.log(`  - 内存过滤: ${filterTime - loadTime}ms`);
console.log(`  - 总耗时: ${endTime - startTime}ms`);
```

**功能**：
- 根据步长动态计算需要加载的数据量
- 步长越小，加载的数据越少
- 添加详细的性能监控日志

**优化效果**：

| 规则 | 步长 | 修改前 | 修改后 | 优化效果 |
|------|------|--------|--------|---------|
| 3秒 | 1 | 30,000 条 | 396 条 | 98.7% ↓ |
| 6秒 | 2 | 30,000 条 | 792 条 | 97.4% ↓ |
| 9秒 | 3 | 30,000 条 | 1,188 条 | 96.0% ↓ |
| 15秒 | 5 | 30,000 条 | 1,980 条 | 93.4% ↓ |
| 30秒 | 10 | 30,000 条 | 3,960 条 | 86.8% ↓ |
| 1分钟 | 20 | 30,000 条 | 7,920 条 | 73.6% ↓ |
| 3分钟 | 60 | 30,000 条 | 23,760 条 | 20.8% ↓ |
| 5分钟 | 100 | 30,000 条 | 30,000 条 | 0% |

---

### 阶段3：优化依赖项（优先级：中）

**已在阶段1中完成**：
- 添加 `blocksCacheRef` 用于在 useCallback 中访问最新的缓存
- 避免将 `blocksCache` 作为依赖项，减少不必要的函数重新创建

---

## 📊 预期性能提升

### 场景1：首次切换到规则（缓存未命中）

#### 步长1（3秒规则）

**修复前**：
```
Redis 加载 30,000 条  →  ~300ms
内存过滤 30,000 条    →  ~100ms
返回 264 条          →  ~10ms
─────────────────────────────
总耗时：~410ms
```

**修复后**：
```
Redis 加载 396 条     →  ~20ms
内存过滤 396 条       →  ~5ms
返回 264 条          →  ~10ms
─────────────────────────────
总耗时：~35ms
性能提升：11.7 倍 ⬆️
```

#### 步长20（1分钟规则）

**修复前**：
```
Redis 加载 30,000 条  →  ~300ms
内存过滤 30,000 条    →  ~100ms
返回 264 条          →  ~10ms
─────────────────────────────
总耗时：~410ms
```

**修复后**：
```
Redis 加载 7,920 条   →  ~80ms
内存过滤 7,920 条     →  ~20ms
返回 264 条          →  ~10ms
─────────────────────────────
总耗时：~110ms
性能提升：3.7 倍 ⬆️
```

---

### 场景2：切换回已访问规则（缓存命中）

**修复前**：
```
Redis 加载 30,000 条  →  ~300ms
内存过滤 30,000 条    →  ~100ms
返回 264 条          →  ~10ms
─────────────────────────────
总耗时：~410ms
```

**修复后**：
```
检查缓存             →  ~1ms
使用缓存数据          →  ~5ms
显示数据             →  ~4ms
─────────────────────────────
总耗时：~10ms
性能提升：41 倍 ⬆️
```

---

### 场景3：频繁切换2个规则

**用户操作**：规则A → 规则B → 规则A → 规则B → 规则A

**修复前**：
```
切换到规则A（首次）  →  ~410ms
切换到规则B（首次）  →  ~410ms
切换回规则A         →  ~410ms  ❌ 重新加载
切换回规则B         →  ~410ms  ❌ 重新加载
切换回规则A         →  ~410ms  ❌ 重新加载
─────────────────────────────
总耗时：~2,050ms
```

**修复后**：
```
切换到规则A（首次）  →  ~35ms   ✅ 后端动态加载
切换到规则B（首次）  →  ~35ms   ✅ 后端动态加载
切换回规则A         →  ~10ms   ✅ 缓存命中
切换回规则B         →  ~10ms   ✅ 缓存命中
切换回规则A         →  ~10ms   ✅ 缓存命中
─────────────────────────────
总耗时：~100ms
性能提升：20.5 倍 ⬆️
```

---

## 🎯 核心优势

### 1. 缓存命中时，完全不需要后端请求

```
用户切换到已访问规则
  ↓
检查前端缓存
  ↓
缓存命中！
  ↓
直接使用缓存数据（~10ms）
  ↓
✅ 不进行网络请求
✅ 不消耗后端资源
✅ 用户体验极佳
```

### 2. 缓存未命中时，后端动态加载减少数据量

```
用户切换到新规则
  ↓
检查前端缓存
  ↓
缓存未命中
  ↓
后端动态计算需要加载的数据量
  ↓
只加载必要的数据（例如：396条而不是30,000条）
  ↓
快速返回（~35ms而不是~410ms）
  ↓
✅ 减少网络传输
✅ 减少内存占用
✅ 减少CPU消耗
```

### 3. 及时清理机制

- **缓存大小限制**：最多保留 10 个规则的缓存
- **清理策略**：FIFO（先进先出）
- **内存占用**：单个规则 132KB，10个规则总计 1.32MB（可接受）

---

## 📈 监控指标

### 前端监控

```typescript
// 1. 缓存命中率
console.log(`[缓存] 📊 命中率: ${(cacheHits / (cacheHits + cacheMisses) * 100).toFixed(1)}%`);

// 2. 缓存大小
console.log(`[缓存] 📊 缓存统计: ${blocksCache.size} 个规则`);

// 3. 内存占用
const estimatedMemory = blocksCache.size * 132;  // KB
console.log(`[缓存] 💾 估算内存占用: ${estimatedMemory.toFixed(0)} KB`);
```

### 后端监控

```typescript
// 1. 数据加载量
console.log(`[API] 📊 预估加载: ${estimatedRawBlocks} 条，实际加载: ${MAX_RAW_BLOCKS} 条`);

// 2. 性能统计
console.log(`[API] ⏱️ 性能统计:`);
console.log(`  - Redis 加载: ${loadTime - startTime}ms`);
console.log(`  - 内存过滤: ${filterTime - loadTime}ms`);
console.log(`  - 总耗时: ${endTime - startTime}ms`);

// 3. 优化效果
const dataReduction = ((1 - MAX_RAW_BLOCKS / 30000) * 100).toFixed(1);
console.log(`[API] 💾 数据加载优化: 减少 ${dataReduction}% 的数据加载`);
```

---

## 🧪 测试建议

### 1. 功能测试

- [ ] 测试首次切换到不同规则（步长 1, 2, 3, 5, 10, 20, 60, 100）
- [ ] 测试切换回已访问的规则（验证缓存命中）
- [ ] 测试频繁切换2-3个规则
- [ ] 测试 WebSocket 接收新区块时缓存是否同步更新
- [ ] 测试缓存清理机制（切换超过10个规则）

### 2. 性能测试

- [ ] 使用浏览器开发者工具的 Network 面板，观察网络请求
- [ ] 使用 Console 查看性能日志
- [ ] 对比优化前后的切换速度
- [ ] 验证缓存命中时是否真的没有网络请求

### 3. 内存测试

- [ ] 使用浏览器开发者工具的 Memory 面板，监控内存占用
- [ ] 验证缓存清理机制是否正常工作
- [ ] 长时间运行，观察内存是否稳定

---

## 📝 总结

### 问题根源
1. ✅ 每次切换规则都强制重新加载数据
2. ✅ 后端每次都加载30,000条原始数据
3. ✅ 前端没有缓存机制
4. ✅ loadHistoryBlocks依赖项过多

### 综合解决方案
1. ✅ **前端缓存**：缓存每个规则的264条符合规则的最新数据
2. ✅ **后端动态加载**：根据步长动态计算需要加载的数据量
3. ✅ **优化依赖项**：使用useRef避免不必要的函数重新创建
4. ✅ **及时清理**：限制缓存大小为10个规则，使用FIFO策略

### 预期效果
- ✅ **缓存命中时**：41倍性能提升（410ms → 10ms）
- ✅ **首次加载（步长1）**：11.7倍性能提升（410ms → 35ms）
- ✅ **首次加载（步长20）**：3.7倍性能提升（410ms → 110ms）
- ✅ **频繁切换2个规则**：20.5倍性能提升（2,050ms → 100ms）

### 核心优势
- ✅ **前端缓存**：缓存命中时，完全不需要后端请求
- ✅ **后端优化**：缓存未命中时，减少数据加载量
- ✅ **协同效果**：两者结合，性能提升最大化
- ✅ **用户体验**：切换规则几乎无延迟

---

**实施完成时间**：2026-02-07  
**实施状态**：✅ 所有阶段已完成  
**下一步**：进行功能测试和性能验证
