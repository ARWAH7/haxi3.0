# 缓存机制根本问题分析

## 问题现象
数据显示：79928784、79928786、79928787
缺少：79928785

## 根本原因

### 缓存机制的局限性

**核心问题**：缓存只能保存已经接收到的数据，无法填补中间缺失的数据。

### 问题场景

1. **用户在规则 A（步长1）**
   - 缓存：79928780, 79928781, 79928782, 79928783, 79928784

2. **切换到规则 B（步长2）**
   - 停留 10 秒
   - WebSocket 推送：79928786, 79928788, 79928790, ...

3. **WebSocket 同步更新规则 A 的缓存**
   - 添加：79928786, 79928788, 79928790, ...
   - ❌ **问题**：缺少 79928785, 79928787, 79928789, ...

4. **切换回规则 A**
   - 使用缓存
   - 显示：79928790, 79928788, 79928786, 79928784, ...
   - ❌ **数据断层**：缺少中间的奇数区块

### 为什么会缺失数据？

**关键点**：WebSocket 只推送新区块，不会推送历史区块。

- 在规则 B 时，79928785、79928787、79928789 已经产生
- 但这些区块不符合规则 B（步长2），所以没有被推送
- 当切换回规则 A 时，这些区块已经是"历史"了
- WebSocket 不会再推送这些历史区块
- 所以规则 A 的缓存永远不会有这些区块

## 解决方案对比

### 方案1：缓存机制（失败）❌

**优点**：
- 性能好（使用缓存）
- 切换快速

**缺点**：
- 无法填补数据断层
- 数据不连续
- 用户体验差

**结论**：缓存机制无法解决根本问题

### 方案2：强制重新加载（推荐）✅

**优点**：
- 数据始终完整
- 数据始终连续
- 逻辑简单

**缺点**：
- 每次切换都需要加载（35-110ms）
- 性能略差

**结论**：牺牲一点性能，换取数据准确性

### 方案3：混合方案（复杂）

**思路**：
- 检测缓存是否有断层
- 如果有断层，从后端填补缺失的数据
- 如果没有断层，使用缓存

**优点**：
- 理论上最优

**缺点**：
- 实现复杂
- 难以维护
- 边界情况多

**结论**：不推荐

## 推荐方案：强制重新加载

### 实现

```typescript
// 规则切换时强制重新加载
useEffect(() => {
  if (!wsConnected || !activeRule) return;
  
  console.log(`[规则变化] 切换到规则: ${activeRule.label}`);
  loadHistoryBlocks(true);  // ✅ forceReload=true，强制重新加载
}, [activeRuleId, wsConnected, loadHistoryBlocks]);
```

### 优化

1. **保留缓存机制**
   - 用于 WebSocket 推送时更新当前规则
   - 不用于规则切换

2. **后端优化**
   - 动态加载（已实现）
   - 步长1：加载 396 条（35ms）
   - 步长20：加载 7920 条（110ms）

3. **用户体验**
   - 35-110ms 的加载时间
   - 用户几乎无感知
   - 数据始终准确

## 性能对比

### 缓存方案（有问题）
- 切换速度：3-5ms ✅
- 数据准确性：❌ 有断层
- 用户体验：⭐⭐

### 强制重新加载方案
- 切换速度：35-110ms ✅ 可接受
- 数据准确性：✅ 完全准确
- 用户体验：⭐⭐⭐⭐⭐

## 结论

**缓存机制无法解决数据断层问题**，因为：
1. WebSocket 只推送新区块，不推送历史区块
2. 切换规则时，中间的区块已经是历史了
3. 缓存永远无法填补这些缺失的区块

**最佳解决方案**：
- 规则切换时强制重新加载
- 牺牲一点性能（35-110ms）
- 换取数据准确性和用户体验

**实施优先级**：
1. 立即实施：强制重新加载
2. 保留优化：后端动态加载
3. 移除：缓存机制（或仅用于当前规则）
