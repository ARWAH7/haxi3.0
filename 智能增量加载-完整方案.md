# 智能增量加载 - 完整方案（待审核）

## 方案概述

### 核心思路
根据你的需求，实现智能增量加载：
1. **检查缓存**：如果有缓存，获取缓存中最新区块高度
2. **计算缺失**：对比链上最新高度，计算缺失的区块数量
3. **智能加载**：
   - 无缺失：直接使用缓存（0ms）
   - 少量缺失（< 50条）：只加载缺失的新区块（5-10ms）
   - 大量缺失（>= 50条）：全量加载（35-110ms）
4. **合并数据**：将新区块合并到缓存中

### 你的场景示例

**场景1：首次打开规则 3秒（步长1）**
- 加载：264 条数据
- 新区块：79929112, 79929113, 79929114, 79929115
- 缓存：包含以上 4 条数据

**场景2：切换到规则 6秒（步长2）**
- 加载：264 条数据
- 新区块：79929116, 79929117, 79929118, 79929119
- 符合规则的：79929116, 79929118（偶数）

**场景3：切回规则 3秒（步长1）**
- 缓存最新：79929115
- 链上最新：79929119
- 缺失：4 条（79929116, 79929117, 79929118, 79929119）
- **智能加载**：只加载这 4 条新数据（5-10ms）
- **合并**：[79929119, 79929118, 79929117, 79929116, 79929115, ...]

## 方案详细设计

### 后端 API 修改

#### 修改1：新增端点 - 获取最新区块高度

**文件**：`backend/src/api.ts`

**位置**：在 `app.use(express.json());` 之后添加

```typescript
// 获取最新区块高度
app.get('/api/blocks/latest-height', async (req, res) => {
  try {
    const blocks = await getBlocks(1);  // 只获取最新的 1 条
    const latestHeight = blocks[0]?.height || 0;
    
    res.json({
      success: true,
      latestHeight
    });
  } catch (error: any) {
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});
```

**说明**：
- 快速获取链上最新区块高度
- 用于计算缺失的区块数量

#### 修改2：增强现有端点 - 支持增量加载

**文件**：`backend/src/api.ts`

**修改点**：在 `/api/blocks` 端点中添加 `fromHeight` 参数支持

```typescript
// 在函数开头添加
const fromHeight = parseInt(req.query.fromHeight as string) || 0;

// 在加载数据后添加过滤逻辑
let allBlocks = await getBlocks(MAX_RAW_BLOCKS);

// ✅ 增量加载：只保留比 fromHeight 更新的区块
if (fromHeight > 0) {
  allBlocks = allBlocks.filter(block => block.height > fromHeight);
  console.log(`[API] 🔄 增量过滤: 保留 ${allBlocks.length} 条新区块（> ${fromHeight}）`);
}

// 在返回结果中添加标记
res.json({
  success: true,
  data: resultBlocks,
  count: resultBlocks.length,
  isIncremental: fromHeight > 0,  // ✅ 标记是否为增量加载
  metadata: {
    // ... 现有字段
    fromHeight,  // ✅ 新增
  }
});
```

**说明**：
- 支持 `fromHeight` 参数，只返回比这个高度更新的区块
- 标记是否为增量加载，方便前端调试

### 前端修改

#### 修改1：恢复缓存机制

**文件**：`App.tsx`

**位置**：`loadHistoryBlocks` 函数

**完整实现**：

```typescript
const loadHistoryBlocks = useCallback(async (forceReload: boolean = false) => {
  try {
    const ruleValue = activeRule?.value || 1;
    const startBlock = activeRule?.startBlock || 0;
    const requiredFiltered = 264;
    const cacheKey = `${ruleValue}-${startBlock}`;
    const BACKEND_API_URL = 'http://localhost:3001';
    
    // ========== 步骤1：检查缓存 ==========
    if (!forceReload && blocksCacheRef.current.has(cacheKey)) {
      const cacheEntry = blocksCacheRef.current.get(cacheKey)!;
      const cachedData = cacheEntry.data;
      const cacheAge = Date.now() - cacheEntry.timestamp;
      
      // 检查缓存是否过期（10秒）
      if (cacheAge > CACHE_TTL) {
        console.log(`[缓存] ⏰ 缓存已过期 (${(cacheAge / 1000).toFixed(1)}秒)，全量加载`);
        // 继续执行全量加载
      } else {
        // ========== 步骤2：获取最新区块高度 ==========
        try {
          const latestHeightRes = await fetch(`${BACKEND_API_URL}/api/blocks/latest-height`);
          const latestHeightData = await latestHeightRes.json();
          const latestHeight = latestHeightData.latestHeight;
          
          // ========== 步骤3：计算缺失区块数量 ==========
          const cachedLatestHeight = cachedData[0]?.height || 0;
          const missingCount = latestHeight - cachedLatestHeight;
          
          console.log(`[缓存] 📊 缓存最新: ${cachedLatestHeight}, 链上最新: ${latestHeight}, 缺失: ${missingCount} 条`);
          
          // ========== 步骤4：决定加载策略 ==========
          if (missingCount === 0) {
            // 策略A：无缺失，直接使用缓存
            console.log(`[缓存] ✅ 数据最新，使用缓存（0ms）`);
            setAllBlocks(cachedData);
            setIsLoading(false);
            return;
          } else if (missingCount > 0 && missingCount < 50) {
            // 策略B：少量缺失，增量加载
            console.log(`[缓存] 🔄 增量加载 ${missingCount} 条新数据`);
            setIsLoading(true);
            
            const response = await fetch(
              `${BACKEND_API_URL}/api/blocks?limit=${missingCount * 2}&ruleValue=${ruleValue}&startBlock=${startBlock}&fromHeight=${cachedLatestHeight}`
            );
            const result = await response.json();
            
            if (result.success && result.data.length > 0) {
              // ========== 步骤5：合并新数据到缓存 ==========
              const combined = [...result.data, ...cachedData];
              const uniqueBlocks = Array.from(new Map(combined.map(b => [b.height, b])).values());
              const sorted = uniqueBlocks.sort((a, b) => b.height - a.height);
              const updated = sorted.slice(0, 264);
              
              // 更新缓存
              setBlocksCache(prev => {
                const newCache = new Map(prev);
                newCache.set(cacheKey, {
                  data: updated,
                  timestamp: Date.now()
                });
                return newCache;
              });
              
              setAllBlocks(updated);
              console.log(`[缓存] ✅ 增量加载完成: 新增 ${result.data.length} 条，总计 ${updated.length} 条`);
              setIsLoading(false);
              return;
            } else {
              console.log(`[缓存] ⚠️ 增量加载失败，切换到全量加载`);
              // 继续执行全量加载
            }
          } else {
            // 策略C：大量缺失，全量加载
            console.log(`[缓存] 🔄 缺失数据过多 (${missingCount} 条)，全量加载`);
            // 继续执行全量加载
          }
        } catch (error) {
          console.error('[缓存] ❌ 检查缓存失败，切换到全量加载:', error);
          // 继续执行全量加载
        }
      }
    }
    
    // ========== 步骤6：全量加载 ==========
    setIsLoading(true);
    console.log(`[API] 🚀 全量加载数据...`);
    
    const response = await fetch(
      `${BACKEND_API_URL}/api/blocks?limit=${requiredFiltered}&ruleValue=${ruleValue}&startBlock=${startBlock}`
    );
    const result = await response.json();
    
    if (result.success) {
      setAllBlocks(result.data);
      
      // 更新缓存
      setBlocksCache(prev => {
        const newCache = new Map(prev);
        newCache.set(cacheKey, {
          data: result.data,
          timestamp: Date.now()
        });
        
        // 限制缓存大小（最多保留 10 个规则）
        if (newCache.size > 10) {
          const firstKey = newCache.keys().next().value;
          newCache.delete(firstKey);
        }
        
        return newCache;
      });
      
      console.log(`[API] ✅ 全量加载完成: ${result.data.length} 条`);
    }
    
    setIsLoading(false);
  } catch (error) {
    console.error('[API] 加载失败:', error);
    setIsLoading(false);
  }
}, [activeRule]);
```

#### 修改2：规则切换逻辑

**文件**：`App.tsx`

**修改**：规则切换时不强制重新加载，优先使用缓存

```typescript
// 规则变化时智能加载数据
useEffect(() => {
  if (!wsConnected || !activeRule) return;
  
  console.log(`[规则变化] 切换到规则: ${activeRule.label}`);
  loadHistoryBlocks(false);  // ✅ 不强制重新加载，优先使用缓存和增量加载
}, [activeRuleId, wsConnected, loadHistoryBlocks]);
```

#### 修改3：WebSocket 同步更新所有规则缓存

**文件**：`App.tsx`

**位置**：WebSocket `onmessage` 处理函数中

**恢复之前的同步更新逻辑**：

```typescript
// ✅ 同步更新所有规则的缓存
setBlocksCache(prevCache => {
  const newCache = new Map(prevCache);
  const now = Date.now();
  
  // 遍历所有已缓存的规则
  Array.from(newCache.entries()).forEach(([cacheKey, cacheEntry]: [string, CacheEntry]) => {
    const [ruleValue, startBlock] = cacheKey.split('-').map(Number);
    
    // 检查新区块是否符合这个规则的步长
    let isAligned = false;
    if (ruleValue <= 1) {
      isAligned = true;
    } else if (startBlock > 0) {
      isAligned = block.height >= startBlock && 
                  (block.height - startBlock) % ruleValue === 0;
    } else {
      isAligned = block.height % ruleValue === 0;
    }
    
    // 只有符合规则步长的区块才添加到缓存
    if (isAligned) {
      const cachedData = cacheEntry.data;
      if (!cachedData.some(b => b.height === block.height)) {
        const updatedCache = [block, ...cachedData].slice(0, 264);
        newCache.set(cacheKey, {
          data: updatedCache,
          timestamp: now
        });
        
        if (process.env.NODE_ENV === 'development') {
          console.log(`[缓存] 🔄 同步更新规则 ${cacheKey} 的缓存（新区块: ${block.height}）`);
        }
      }
    }
  });
  
  return newCache;
});
```

## 性能分析

### 场景1：无缺失数据
- **操作**：切换到已缓存的规则，数据最新
- **耗时**：0ms（直接使用缓存）
- **日志**：`[缓存] ✅ 数据最新，使用缓存（0ms）`

### 场景2：少量缺失（你的场景）
- **操作**：切换到已缓存的规则，缺失 4 条新数据
- **耗时**：5-10ms（只加载 4 条）
- **日志**：
  ```
  [缓存] 📊 缓存最新: 79929115, 链上最新: 79929119, 缺失: 4 条
  [缓存] 🔄 增量加载 4 条新数据
  [缓存] ✅ 增量加载完成: 新增 4 条，总计 264 条
  ```

### 场景3：大量缺失
- **操作**：切换到已缓存的规则，缺失 50+ 条数据
- **耗时**：35-110ms（全量加载）
- **日志**：
  ```
  [缓存] 📊 缓存最新: 79929000, 链上最新: 79929119, 缺失: 119 条
  [缓存] 🔄 缺失数据过多 (119 条)，全量加载
  [API] ✅ 全量加载完成: 264 条
  ```

### 场景4：缓存过期
- **操作**：切换到已缓存的规则，缓存超过 10 秒
- **耗时**：35-110ms（全量加载）
- **日志**：
  ```
  [缓存] ⏰ 缓存已过期 (12.3秒)，全量加载
  [API] ✅ 全量加载完成: 264 条
  ```

## 优势总结

1. **性能最优**
   - 无缺失：0ms
   - 少量缺失：5-10ms（你的场景）
   - 大量缺失：35-110ms

2. **数据完整**
   - WebSocket 同步更新所有规则缓存
   - 增量加载填补缺失数据
   - 数据始终连续

3. **逻辑智能**
   - 自动判断加载策略
   - 最大化性能
   - 兜底机制完善

4. **用户体验**
   - 切换快速
   - 数据准确
   - 无感知

## 需要审核的点

### 1. 缓存过期时间
- 当前：10秒
- 建议：保持 10秒
- 原因：平衡性能和数据新鲜度

### 2. 增量加载阈值
- 当前：< 50 条使用增量加载
- 建议：保持 50 条
- 原因：50 条以内增量加载更快，超过 50 条全量加载更稳定

### 3. WebSocket 同步更新
- 当前：同步更新所有规则缓存
- 建议：保持同步更新
- 原因：保持所有缓存实时性，配合增量加载效果最佳

### 4. 缓存大小限制
- 当前：最多保留 10 个规则
- 建议：保持 10 个
- 原因：足够大部分使用场景，避免内存占用过高

## 实施步骤

1. **后端修改**（2 处）
   - 添加 `/api/blocks/latest-height` 端点
   - 增强 `/api/blocks` 端点，支持 `fromHeight` 参数

2. **前端修改**（3 处）
   - 修改 `loadHistoryBlocks` 函数，实现智能增量加载
   - 修改规则切换逻辑，不强制重新加载
   - 恢复 WebSocket 同步更新所有规则缓存

3. **测试验证**
   - 测试无缺失场景
   - 测试少量缺失场景（你的场景）
   - 测试大量缺失场景
   - 测试缓存过期场景

## 请审核

请审核以上方案，如果同意，我将开始实施修改。如果有任何疑问或需要调整的地方，请告诉我。
