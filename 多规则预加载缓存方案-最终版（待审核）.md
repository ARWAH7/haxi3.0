# 多规则预加载缓存方案 - 最终版（待审核）

## 方案概述

### 核心功能

1. **智能预加载**
   - 前端启动时，自动预加载所有存在的规则（不限于 4 个默认规则）
   - 从后端 Redis 读取用户保存的规则列表
   - 并行加载每个规则的 264 条数据

2. **规则同步管理**
   - 规则删除时，自动清除对应的缓存数据
   - 规则创建时，自动加载并加入缓存
   - 规则修改时，重新加载数据

3. **WebSocket 实时同步**
   - 新区块到达时，检查符合哪些规则
   - 只更新已缓存规则的数据
   - 不符合任何规则的数据不保存

4. **规则切换优化**
   - 已缓存规则：0ms 切换
   - 未缓存规则：首次加载后加入缓存

### 用户场景示例

**场景 1：首次启动**
```
1. 前端启动
2. 从 Redis 读取规则列表：[步长1, 步长20, 步长60, 步长100]
3. 并行加载 4 个规则的数据（50-70ms）
4. 缓存：
   - Map["1-0"] = 264 条数据
   - Map["20-0"] = 264 条数据
   - Map["60-0"] = 264 条数据
   - Map["100-0"] = 264 条数据
5. 完成，用户可以 0ms 切换规则
```

**场景 2：删除规则**
```
1. 用户删除规则"步长20"
2. 前端删除缓存 Map["20-0"]
3. WebSocket 不再更新这个规则
4. 内存释放
```

**场景 3：创建新规则**
```
1. 用户创建规则"步长5"
2. 前端加载这个规则的 264 条数据（35ms）
3. 添加到缓存 Map["5-0"]
4. WebSocket 开始同步更新这个规则
5. 完成，用户可以 0ms 切换到这个规则
```

**场景 4：WebSocket 推送新区块**
```
1. 新区块 79929120 到达
2. 检查所有已缓存的规则：
   - 步长1：79929120 % 1 === 0 ✅ → 更新缓存
   - 步长20：79929120 % 20 === 0 ✅ → 更新缓存
   - 步长60：79929120 % 60 === 0 ✅ → 更新缓存
   - 步长100：79929120 % 100 === 0 ✅ → 更新缓存
3. 所有缓存保持最新
```

---

## 详细设计

### 1. 数据结构

#### 缓存结构
```typescript
interface CacheEntry {
  data: BlockData[];      // 264 条区块数据
  timestamp: number;      // 最后更新时间
  ruleId: string;         // 规则 ID（用于追踪）
}

// 缓存 Map
// Key: "ruleValue-startBlock" (例如: "1-0", "20-0")
// Value: CacheEntry
const blocksCache = new Map<string, CacheEntry>();
```

#### 规则追踪
```typescript
// 追踪哪些规则已经预加载
const preloadedRules = useRef<Set<string>>(new Set());
```


### 2. 预加载逻辑

#### 实现位置
**文件**：`App.tsx`  
**触发时机**：WebSocket 连接成功后

#### 代码实现
```typescript
// 预加载所有规则的数据
const preloadAllRules = useCallback(async () => {
  if (rules.length === 0) {
    console.log('[预加载] ⚠️ 没有规则需要预加载');
    return;
  }
  
  console.log('[预加载] 🚀 开始预加载所有规则...');
  console.log('[预加载] 📋 规则列表:', rules.map(r => r.label).join(', '));
  
  const startTime = Date.now();
  const BACKEND_API_URL = 'http://localhost:3001';
  
  // 并行加载所有规则
  const promises = rules.map(async (rule) => {
    try {
      const response = await fetch(
        `${BACKEND_API_URL}/api/blocks?limit=264&ruleValue=${rule.value}&startBlock=${rule.startBlock}`
      );
      const result = await response.json();
      
      if (result.success) {
        const cacheKey = `${rule.value}-${rule.startBlock}`;
        console.log(`[预加载] ✅ 规则 ${rule.label} 加载完成: ${result.data.length} 条`);
        return { 
          cacheKey, 
          data: result.data,
          ruleId: rule.id
        };
      }
    } catch (error) {
      console.error(`[预加载] ❌ 规则 ${rule.label} 加载失败:`, error);
    }
    return null;
  });
  
  const results = await Promise.all(promises);
  
  // 更新缓存
  setBlocksCache(prev => {
    const newCache = new Map(prev);
    const now = Date.now();
    
    results.forEach(result => {
      if (result) {
        newCache.set(result.cacheKey, {
          data: result.data,
          timestamp: now,
          ruleId: result.ruleId
        });
        preloadedRules.current.add(result.ruleId);
      }
    });
    
    return newCache;
  });
  
  const endTime = Date.now();
  const successCount = results.filter(r => r).length;
  console.log(`[预加载] ✅ 预加载完成，耗时: ${endTime - startTime}ms`);
  console.log(`[预加载] 📊 成功: ${successCount}/${rules.length} 个规则`);
  console.log(`[预加载] 💾 内存占用: 约 ${(successCount * 264 * 0.5 / 1024).toFixed(2)} MB`);
}, [rules]);

// WebSocket 连接成功后调用
ws.onopen = () => {
  setWsConnected(true);
  setConnectionError(null);
  console.log('[连接] ✅ WebSocket 连接成功');
  
  // 重置重连次数
  reconnectAttempts = 0;
  
  // 只在首次连接时预加载
  if (isFirstConnection) {
    isFirstConnection = false;
    preloadAllRules();
  }
};
```


### 3. 规则删除处理

#### 实现位置
**文件**：`App.tsx`  
**触发时机**：用户删除规则时

#### 代码实现
```typescript
const deleteRule = (id: string) => {
  if (rules.length <= 1) return;
  
  // 找到要删除的规则
  const ruleToDelete = rules.find(r => r.id === id);
  
  setRules(prev => {
    const filtered = prev.filter(r => r.id !== id);
    if (activeRuleId === id) setActiveRuleId(filtered[0]?.id || '');
    return filtered;
  });
  
  // 清除对应的缓存
  if (ruleToDelete) {
    const cacheKey = `${ruleToDelete.value}-${ruleToDelete.startBlock}`;
    setBlocksCache(prev => {
      const newCache = new Map(prev);
      if (newCache.has(cacheKey)) {
        newCache.delete(cacheKey);
        console.log(`[缓存] 🗑️ 删除规则 ${ruleToDelete.label} 的缓存: ${cacheKey}`);
      }
      return newCache;
    });
    
    // 从预加载追踪中移除
    preloadedRules.current.delete(id);
    
    console.log(`[规则] ✅ 规则 ${ruleToDelete.label} 已删除，缓存已清理`);
  }
};

// 批量删除规则
const deleteSelectedRules = () => {
  if (selectedRuleIds.size === 0) return;
  if (selectedRuleIds.size >= rules.length) {
    alert('至少保留一条采样规则');
    return;
  }
  const confirmed = window.confirm(`确定删除选中的 ${selectedRuleIds.size} 条规则吗？`);
  if (!confirmed) return;

  // 找到要删除的规则
  const rulesToDelete = rules.filter(r => selectedRuleIds.has(r.id));
  
  setRules(prev => {
    const filtered = prev.filter(r => !selectedRuleIds.has(r.id));
    if (selectedRuleIds.has(activeRuleId)) setActiveRuleId(filtered[0]?.id || '');
    return filtered;
  });
  
  // 批量清除缓存
  setBlocksCache(prev => {
    const newCache = new Map(prev);
    rulesToDelete.forEach(rule => {
      const cacheKey = `${rule.value}-${rule.startBlock}`;
      if (newCache.has(cacheKey)) {
        newCache.delete(cacheKey);
        console.log(`[缓存] 🗑️ 删除规则 ${rule.label} 的缓存: ${cacheKey}`);
      }
      preloadedRules.current.delete(rule.id);
    });
    return newCache;
  });
  
  setSelectedRuleIds(new Set());
  console.log(`[规则] ✅ 已删除 ${rulesToDelete.length} 个规则，缓存已清理`);
};
```


### 4. 规则创建处理

#### 实现位置
**文件**：`App.tsx`  
**触发时机**：用户创建新规则时

#### 代码实现
```typescript
const handleSaveRule = async (e: React.FormEvent) => {
  e.preventDefault();
  if (!editingRule) return;
  
  const isNewRule = !rules.find(r => r.id === editingRule.id);
  
  if (isNewRule) {
    // 新规则：添加到列表
    setRules(prev => [...prev, editingRule]);
    
    // 立即加载新规则的数据
    console.log(`[规则] 🆕 创建新规则: ${editingRule.label}，开始加载数据...`);
    
    try {
      const BACKEND_API_URL = 'http://localhost:3001';
      const response = await fetch(
        `${BACKEND_API_URL}/api/blocks?limit=264&ruleValue=${editingRule.value}&startBlock=${editingRule.startBlock}`
      );
      const result = await response.json();
      
      if (result.success) {
        const cacheKey = `${editingRule.value}-${editingRule.startBlock}`;
        setBlocksCache(prev => {
          const newCache = new Map(prev);
          newCache.set(cacheKey, {
            data: result.data,
            timestamp: Date.now(),
            ruleId: editingRule.id
          });
          return newCache;
        });
        
        preloadedRules.current.add(editingRule.id);
        console.log(`[规则] ✅ 新规则 ${editingRule.label} 数据加载完成: ${result.data.length} 条`);
      }
    } catch (error) {
      console.error(`[规则] ❌ 新规则 ${editingRule.label} 数据加载失败:`, error);
    }
  } else {
    // 现有规则：更新
    const oldRule = rules.find(r => r.id === editingRule.id);
    setRules(prev => prev.map(r => r.id === editingRule.id ? editingRule : r));
    
    // 检查规则的步长或偏移是否改变
    if (oldRule && (oldRule.value !== editingRule.value || oldRule.startBlock !== editingRule.startBlock)) {
      console.log(`[规则] 🔄 规则 ${editingRule.label} 的步长或偏移已改变，重新加载数据...`);
      
      // 删除旧缓存
      const oldCacheKey = `${oldRule.value}-${oldRule.startBlock}`;
      setBlocksCache(prev => {
        const newCache = new Map(prev);
        newCache.delete(oldCacheKey);
        return newCache;
      });
      
      // 加载新数据
      try {
        const BACKEND_API_URL = 'http://localhost:3001';
        const response = await fetch(
          `${BACKEND_API_URL}/api/blocks?limit=264&ruleValue=${editingRule.value}&startBlock=${editingRule.startBlock}`
        );
        const result = await response.json();
        
        if (result.success) {
          const newCacheKey = `${editingRule.value}-${editingRule.startBlock}`;
          setBlocksCache(prev => {
            const newCache = new Map(prev);
            newCache.set(newCacheKey, {
              data: result.data,
              timestamp: Date.now(),
              ruleId: editingRule.id
            });
            return newCache;
          });
          
          console.log(`[规则] ✅ 规则 ${editingRule.label} 数据重新加载完成: ${result.data.length} 条`);
        }
      } catch (error) {
        console.error(`[规则] ❌ 规则 ${editingRule.label} 数据重新加载失败:`, error);
      }
    }
  }
  
  setEditingRule(null);
};
```


### 5. WebSocket 同步更新

#### 实现位置
**文件**：`App.tsx`  
**触发时机**：WebSocket 接收到新区块

#### 代码实现
```typescript
ws.onmessage = (event) => {
  try {
    const data = JSON.parse(event.data);
    
    // 跳过系统消息
    if (data.type === 'connected') {
      console.log('[连接]', data.message);
      return;
    }
    
    const block = data;
    
    // 减少日志输出，只在开发模式下显示详细日志
    if (process.env.NODE_ENV === 'development') {
      console.log(`[Redis WS] 📦 新区块: ${block.height} (${block.type}, ${block.sizeType})`);
    }
    
    // 同步更新所有已缓存规则
    setBlocksCache(prevCache => {
      const newCache = new Map(prevCache);
      const now = Date.now();
      let updateCount = 0;
      
      // 遍历所有已缓存的规则
      Array.from(newCache.entries()).forEach(([cacheKey, cacheEntry]) => {
        const [ruleValue, startBlock] = cacheKey.split('-').map(Number);
        
        // 检查新区块是否符合这个规则
        let isAligned = false;
        if (ruleValue <= 1) {
          isAligned = true;
        } else if (startBlock > 0) {
          isAligned = block.height >= startBlock && 
                      (block.height - startBlock) % ruleValue === 0;
        } else {
          isAligned = block.height % ruleValue === 0;
        }
        
        // 如果符合规则，更新缓存
        if (isAligned) {
          const cachedData = cacheEntry.data;
          
          // 去重检查
          if (!cachedData.some(b => b.height === block.height)) {
            const updated = [block, ...cachedData].slice(0, 264);
            newCache.set(cacheKey, {
              data: updated,
              timestamp: now,
              ruleId: cacheEntry.ruleId
            });
            updateCount++;
          }
        }
      });
      
      if (updateCount > 0 && process.env.NODE_ENV === 'development') {
        console.log(`[WebSocket] 🔄 同步更新 ${updateCount} 个规则缓存（区块: ${block.height}）`);
      }
      
      return newCache;
    });
    
    // 更新当前激活规则的显示数据
    const currentRule = activeRuleRef.current;
    if (currentRule) {
      const cacheKey = `${currentRule.value}-${currentRule.startBlock}`;
      const cacheEntry = blocksCacheRef.current.get(cacheKey);
      if (cacheEntry) {
        setAllBlocks(cacheEntry.data);
      }
    }
  } catch (error) {
    console.error('[WebSocket] 解析消息失败:', error);
  }
};
```


### 6. 规则切换优化

#### 实现位置
**文件**：`App.tsx`  
**触发时机**：用户切换规则

#### 代码实现
```typescript
const loadHistoryBlocks = useCallback(async (forceReload: boolean = false) => {
  try {
    const ruleValue = activeRule?.value || 1;
    const startBlock = activeRule?.startBlock || 0;
    const cacheKey = `${ruleValue}-${startBlock}`;
    const BACKEND_API_URL = 'http://localhost:3001';
    
    // 检查缓存
    if (!forceReload && blocksCacheRef.current.has(cacheKey)) {
      const cacheEntry = blocksCacheRef.current.get(cacheKey)!;
      const cacheAge = Date.now() - cacheEntry.timestamp;
      
      // 缓存未过期（30秒）
      if (cacheAge < 30000) {
        console.log(`[缓存] ✅ 使用缓存（0ms），规则: ${activeRule?.label}`);
        setAllBlocks(cacheEntry.data);
        return;
      } else {
        console.log(`[缓存] ⏰ 缓存已过期 (${(cacheAge / 1000).toFixed(1)}秒)，重新加载`);
      }
    }
    
    // 缓存不存在或已过期，从后端加载
    setIsLoading(true);
    console.log(`[API] 🚀 加载规则: ${activeRule?.label}`);
    
    const response = await fetch(
      `${BACKEND_API_URL}/api/blocks?limit=264&ruleValue=${ruleValue}&startBlock=${startBlock}`
    );
    const result = await response.json();
    
    if (result.success) {
      setAllBlocks(result.data);
      
      // 更新缓存
      setBlocksCache(prev => {
        const newCache = new Map(prev);
        newCache.set(cacheKey, {
          data: result.data,
          timestamp: Date.now(),
          ruleId: activeRule?.id || ''
        });
        return newCache;
      });
      
      // 标记为已预加载
      if (activeRule?.id) {
        preloadedRules.current.add(activeRule.id);
      }
      
      console.log(`[API] ✅ 加载完成: ${result.data.length} 条`);
    }
    
    setIsLoading(false);
  } catch (error) {
    console.error('[API] 加载失败:', error);
    setIsLoading(false);
  }
}, [activeRule]);

// 规则变化时智能加载数据
useEffect(() => {
  if (!wsConnected || !activeRule) return;
  
  console.log(`[规则变化] 切换到规则: ${activeRule.label}`);
  loadHistoryBlocks(false);  // 优先使用缓存
}, [activeRuleId, wsConnected, loadHistoryBlocks]);
```


---

## 性能分析

### 首次启动

**场景**：用户有 4 个规则（步长 1, 20, 60, 100）

```
1. 前端启动
2. 从 Redis 加载规则列表（10ms）
3. 并行加载 4 个规则的数据（50-70ms）
4. 总耗时：60-80ms
5. 用户感知：几乎无感知（后台加载）
```

### 规则切换

**场景 1：切换到已缓存的规则**
```
耗时：0ms ✅
日志：[缓存] ✅ 使用缓存（0ms），规则: 步长20
```

**场景 2：切换到未缓存的规则（新创建）**
```
耗时：35-110ms（取决于步长）
日志：[API] 🚀 加载规则: 步长5
      [API] ✅ 加载完成: 264 条
```

### 规则删除

**场景**：删除规则"步长20"
```
1. 删除规则（1ms）
2. 清除缓存（1ms）
3. 总耗时：2ms
4. 内存释放：约 0.13MB
```

### 规则创建

**场景**：创建规则"步长5"
```
1. 创建规则（1ms）
2. 加载数据（35ms）
3. 添加到缓存（1ms）
4. 总耗时：37ms
5. 内存增加：约 0.13MB
```

### WebSocket 同步

**场景**：新区块 79929120 到达
```
1. 检查 4 个已缓存规则（1ms）
2. 更新符合的规则缓存（1ms）
3. 总耗时：2ms
4. 性能影响：可忽略
```

### 内存占用

**场景 1：4 个默认规则**
```
4 个规则 × 264 条 × 0.5KB = 0.5MB
```

**场景 2：10 个规则（上限）**
```
10 个规则 × 264 条 × 0.5KB = 1.3MB
```

**结论**：内存占用完全可接受

---

## 优势总结

### ✅ 性能最优
- **规则切换**：0ms（已缓存规则）
- **首次启动**：60-80ms（并行加载）
- **WebSocket 同步**：2ms/区块

### ✅ 数据完整
- **WebSocket 同步**：所有规则实时更新
- **无数据断层**：每个规则的缓存都是连续的
- **数据准确**：始终保持最新

### ✅ 内存可控
- **动态管理**：只缓存存在的规则
- **自动清理**：规则删除时清除缓存
- **内存占用**：0.5-1.3MB（完全可接受）

### ✅ 用户体验
- **无感知切换**：0ms 延迟
- **智能预加载**：后台加载，不影响使用
- **即时响应**：创建规则后立即可用

### ✅ 逻辑清晰
- **预加载**：启动时自动加载所有规则
- **同步更新**：WebSocket 实时更新所有缓存
- **动态管理**：规则增删改自动处理缓存

---

## 实施计划

### 第 1 步：后端修改
- **无需修改**：现有 API 已支持

### 第 2 步：前端修改（约 2 小时）

#### 修改 1：添加预加载逻辑（30 分钟）
- 位置：WebSocket 连接成功后
- 代码量：约 40 行
- 功能：并行加载所有规则的数据

#### 修改 2：修改规则删除逻辑（15 分钟）
- 位置：`deleteRule` 和 `deleteSelectedRules` 函数
- 代码量：约 15 行
- 功能：删除规则时清除对应缓存

#### 修改 3：修改规则创建逻辑（30 分钟）
- 位置：`handleSaveRule` 函数
- 代码量：约 50 行
- 功能：创建/修改规则时加载数据

#### 修改 4：修改 WebSocket 同步逻辑（30 分钟）
- 位置：WebSocket `onmessage` 处理函数
- 代码量：约 30 行
- 功能：同步更新所有已缓存规则

#### 修改 5：修改规则切换逻辑（15 分钟）
- 位置：`loadHistoryBlocks` 函数
- 代码量：约 10 行
- 功能：优先使用缓存

### 第 3 步：测试验证（30 分钟）

#### 测试 1：预加载测试
- 启动前端，检查是否加载所有规则
- 验证缓存是否正确创建

#### 测试 2：规则删除测试
- 删除规则，检查缓存是否清除
- 验证内存是否释放

#### 测试 3：规则创建测试
- 创建新规则，检查是否立即加载数据
- 验证缓存是否正确添加

#### 测试 4：WebSocket 同步测试
- 等待新区块，检查是否同步更新所有规则
- 验证数据是否连续

#### 测试 5：规则切换测试
- 切换规则，检查是否 0ms 延迟
- 验证数据是否正确

### 第 4 步：上线部署（10 分钟）
- 合并代码
- 部署前端
- 监控性能

---

## 风险评估

### 风险 1：首次启动时间增加
- **风险等级**：低
- **影响**：首次启动增加 60-80ms
- **缓解**：并行加载，用户几乎无感知

### 风险 2：内存占用增加
- **风险等级**：低
- **影响**：内存增加 0.5-1.3MB
- **缓解**：现代浏览器完全可接受

### 风险 3：WebSocket 同步性能
- **风险等级**：极低
- **影响**：每个区块增加 2ms 处理时间
- **缓解**：性能影响可忽略

### 风险 4：规则数量过多
- **风险等级**：低
- **影响**：规则数量过多时，内存占用增加
- **缓解**：限制最多 10 个规则（1.3MB）

---

## 总结

### 核心优势
1. ✅ **性能最优**：规则切换 0ms
2. ✅ **数据完整**：WebSocket 同步，无断层
3. ✅ **内存可控**：0.5-1.3MB，完全可接受
4. ✅ **用户体验**：无感知切换，即时响应
5. ✅ **逻辑清晰**：自动管理缓存，易于维护

### 实施建议
- **立即实施**：方案成熟，风险低
- **预计耗时**：2-3 小时（开发 + 测试）
- **预期效果**：规则切换性能提升 100%

### 下一步
**请审核以上方案，如果同意，我将立即开始实施修改。**
