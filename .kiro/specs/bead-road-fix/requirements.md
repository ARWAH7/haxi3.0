# 需求文档：修复珠盘路显示问题

## 简介

本规范旨在修复单双、大小珠盘路的显示问题。当前实现中，`calculateBeadGrid` 函数接收了 `interval` 和 `startBlock` 参数但从未使用，导致珠盘路显示的数据可能与当前规则不匹配。此外，数据填充逻辑需要优化，确保正确的从左到右、从上到下的填充顺序。

## 术语表

- **珠盘路（Bead_Road）**: 一个固定的 6 行 × 44 列网格，用于显示区块数据
- **规则（Rule）**: 定义数据采样的步长（interval）和起始偏移（startBlock）
- **步长（Interval）**: 每隔多少个区块采样一次数据
- **起始偏移（StartBlock）**: 从哪个区块高度开始采样
- **网格单元（GridCell）**: 珠盘路中的单个单元格，包含类型、值和区块高度信息
- **按列滑动（Column_Sliding）**: 当数据填满后，每次删除最左边一整列（6条数据），所有列向左移动

## 需求

### 需求 1：修复 calculateBeadGrid 函数的参数使用

**用户故事：** 作为开发者，我希望 `calculateBeadGrid` 函数正确使用传入的 `interval` 和 `startBlock` 参数，以便珠盘路能够显示符合当前规则的数据。

#### 验收标准

1. WHEN `calculateBeadGrid` 函数被调用时，THE 函数 SHALL 使用传入的 `interval` 和 `startBlock` 参数进行数据过滤
2. WHEN 数据不符合规则时，THE 函数 SHALL 跳过这些数据，不将其添加到网格中
3. WHEN 规则步长为 1 时，THE 函数 SHALL 接受所有区块数据
4. WHEN 规则步长大于 1 时，THE 函数 SHALL 只接受符合步长和偏移规则的区块数据

### 需求 2：优化珠盘路数据填充逻辑（按列滑动）

**用户故事：** 作为用户，我希望珠盘路按照正确的顺序填充数据（从左到右、从上到下），并且当数据填满后，新数据以"列"为单位滑动显示，以便我能够清晰地看到数据的时间顺序。

#### 珠盘路填充逻辑说明

珠盘路是一个固定的 **6 行 × 44 列** 网格，总容量为 **264 个单元格**。数据填充遵循以下规则：

**填充顺序：**
```
列0  列1  列2  列3  ...  列43
[0]  [6]  [12] [18] ...  [258]  ← 行0（最上面）
[1]  [7]  [13] [19] ...  [259]  ← 行1
[2]  [8]  [14] [20] ...  [260]  ← 行2
[3]  [9]  [15] [21] ...  [261]  ← 行3
[4]  [10] [16] [22] ...  [262]  ← 行4
[5]  [11] [17] [23] ...  [263]  ← 行5（最下面）
```

**数据索引计算公式：**
- 列号（col）= Math.floor(索引 / 6)
- 行号（row）= 索引 % 6

**示例 1：少量数据（15 条）**

```
时间顺序：旧 → 新
数据：[100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114]

填充结果（6行 × 44列，只显示前3列）：
列0    列1    列2    列3-43
[100]  [106]  [112]  [空]   ← 行0
[101]  [107]  [113]  [空]   ← 行1
[102]  [108]  [114]  [空]   ← 行2
[103]  [109]  [空]   [空]   ← 行3
[104]  [110]  [空]   [空]   ← 行4
[105]  [111]  [空]   [空]   ← 行5
```

**示例 2：完整数据（264 条，区块高度 136-399）**

```
时间顺序：旧 → 新
数据：[136, 137, 138, ..., 397, 398, 399]（共 264 条）

填充结果（6行 × 44列，完整展示）：
列0    列1    列2    列3    列4    列5    ...  列41   列42   列43
[136]  [142]  [148]  [154]  [160]  [166]  ...  [382]  [388]  [394]  ← 行0
[137]  [143]  [149]  [155]  [161]  [167]  ...  [383]  [389]  [395]  ← 行1
[138]  [144]  [150]  [156]  [162]  [168]  ...  [384]  [390]  [396]  ← 行2
[139]  [145]  [151]  [157]  [163]  [169]  ...  [385]  [391]  [397]  ← 行3
[140]  [146]  [152]  [158]  [164]  [170]  ...  [386]  [392]  [398]  ← 行4
[141]  [147]  [153]  [159]  [165]  [171]  ...  [387]  [393]  [399]  ← 行5

说明：
- 第 0 列：区块 136-141（最旧的 6 条数据）
- 第 1 列：区块 142-147
- 第 2 列：区块 148-153
- ...
- 第 43 列：区块 394-399（最新的 6 条数据）
- 总共：44 列 × 6 行 = 264 个单元格，全部填满
```

**示例 3：实时更新场景（按列滑动）**

**初始状态：显示区块 136-399（264 条，填满所有单元格）**

```
保留数据：[136, 137, 138, ..., 397, 398, 399]（264 条）

填充结果（6行 × 44列）：
列0    列1    列2    列3    列4    列5    ...  列41   列42   列43
[136]  [142]  [148]  [154]  [160]  [166]  ...  [382]  [388]  [394]  ← 行0
[137]  [143]  [149]  [155]  [161]  [167]  ...  [383]  [389]  [395]  ← 行1
[138]  [144]  [150]  [156]  [162]  [168]  ...  [384]  [390]  [396]  ← 行2
[139]  [145]  [151]  [157]  [163]  [169]  ...  [385]  [391]  [397]  ← 行3
[140]  [146]  [152]  [158]  [164]  [170]  ...  [386]  [392]  [398]  ← 行4
[141]  [147]  [153]  [159]  [165]  [171]  ...  [387]  [393]  [399]  ← 行5
```

**第 1 次更新：新区块 400 到达**

```
操作：
1. 新区块 400 添加到数组开头
2. 数组长度：265 条（超过容量）
3. 按列滑动：删除列0的所有数据（区块 136-141，共 6 条）
4. 最终数据：[142, 143, 144, ..., 398, 399, 400]（259 条）

保留数据：[142, 143, 144, ..., 398, 399, 400]（259 条）

填充结果（6行 × 44列）：
列0    列1    列2    列3    列4    列5    ...  列41   列42   列43
[142]  [148]  [154]  [160]  [166]  [172]  ...  [388]  [394]  [400]  ← 行0
[143]  [149]  [155]  [161]  [167]  [173]  ...  [389]  [395]  [空]   ← 行1
[144]  [150]  [156]  [162]  [168]  [174]  ...  [390]  [396]  [空]   ← 行2
[145]  [151]  [157]  [163]  [169]  [175]  ...  [391]  [397]  [空]   ← 行3
[146]  [152]  [158]  [164]  [170]  [176]  ...  [392]  [398]  [空]   ← 行4
[147]  [153]  [159]  [165]  [171]  [177]  ...  [393]  [399]  [空]   ← 行5

变化：
- 删除：列0 的所有数据（区块 136-141）
- 新增：列42 行0 的区块 400
- 所有列向左移动一列
- 列43 出现 5 个空单元格
```

**第 2-6 次更新：新区块 401-405 陆续到达**

```
每次新区块到达时，填充列43的下一个空位置，直到列43填满：

第 2 次：区块 401 → 列43 行1
第 3 次：区块 402 → 列43 行2
第 4 次：区块 403 → 列43 行3
第 5 次：区块 404 → 列43 行4
第 6 次：区块 405 → 列43 行5

最终数据：[142, 143, 144, ..., 403, 404, 405]（264 条，再次填满）

填充结果（6行 × 44列）：
列0    列1    列2    列3    列4    列5    ...  列41   列42   列43
[142]  [148]  [154]  [160]  [166]  [172]  ...  [388]  [394]  [400]  ← 行0
[143]  [149]  [155]  [161]  [167]  [173]  ...  [389]  [395]  [401]  ← 行1
[144]  [150]  [156]  [162]  [168]  [174]  ...  [390]  [396]  [402]  ← 行2
[145]  [151]  [157]  [163]  [169]  [175]  ...  [391]  [397]  [403]  ← 行3
[146]  [152]  [158]  [164]  [170]  [176]  ...  [392]  [398]  [404]  ← 行4
[147]  [153]  [159]  [165]  [171]  [177]  ...  [393]  [399]  [405]  ← 行5
```

**第 7 次更新：新区块 406 到达（再次触发列滑动）**

```
操作：
1. 新区块 406 添加到数组开头
2. 数组长度：265 条（超过容量）
3. 按列滑动：删除列0的所有数据（区块 142-147，共 6 条）
4. 最终数据：[148, 149, 150, ..., 404, 405, 406]（259 条）

保留数据：[148, 149, 150, ..., 404, 405, 406]（259 条）

填充结果（6行 × 44列）：
列0    列1    列2    列3    列4    列5    ...  列41   列42   列43
[148]  [154]  [160]  [166]  [172]  [178]  ...  [394]  [400]  [406]  ← 行0
[149]  [155]  [161]  [167]  [173]  [179]  ...  [395]  [401]  [空]   ← 行1
[150]  [156]  [162]  [168]  [174]  [180]  ...  [396]  [402]  [空]   ← 行2
[151]  [157]  [163]  [169]  [175]  [181]  ...  [397]  [403]  [空]   ← 行3
[152]  [158]  [164]  [170]  [176]  [182]  ...  [398]  [404]  [空]   ← 行4
[153]  [159]  [165]  [171]  [177]  [183]  ...  [399]  [405]  [空]   ← 行5

变化：
- 删除：列0 的所有数据（区块 142-147）
- 新增：列43 行0 的区块 406
- 所有列向左移动一列
- 列43 出现 5 个空单元格
```

**关键规律总结：**

1. **按列滑动机制**：当数据填满 264 条后，每次新区块到达时：
   - 如果列43未填满，新数据填充到列43的下一个空位置
   - 如果列43已填满，删除列0的所有数据（6条），所有列向左移动一列，新数据填充到列43行0

2. **填充顺序不变**：始终按照从左到右、从上到下的顺序填充

3. **视觉效果**：数据看起来像是以"列"为单位从左向右"流动"

4. **自动滚动**：珠盘路组件应自动滚动到最右侧，确保用户看到最新数据

5. **批量删除**：每次删除一整列（6条数据），而不是逐条删除

#### 验收标准

1. WHEN 数据被填充到珠盘路时，THE 系统 SHALL 按照从左到右、从上到下的顺序填充
2. WHEN 一列填满 6 个单元格后，THE 系统 SHALL 移动到下一列继续填充
3. WHEN 数据超过 264 条且列43已填满时，THE 系统 SHALL 删除列0的所有数据（6条）
4. WHEN 数据不足 264 条时，THE 系统 SHALL 用空单元格填充剩余位置
5. WHEN 新区块到达且列43未填满时，THE 系统 SHALL 将其添加到列43的下一个空位置
6. WHEN 新区块到达且列43已填满时，THE 系统 SHALL 删除列0，所有列向左移动，新数据填充到列43行0

### 需求 3：确保珠盘路正确响应规则切换

**用户故事：** 作为用户，我希望切换规则时珠盘路能够立即更新并显示符合新规则的数据，以便我能够查看不同规则下的数据分布。

#### 验收标准

1. WHEN 用户切换规则时，THE 系统 SHALL 重新计算珠盘路网格
2. WHEN 规则切换完成后，THE 珠盘路 SHALL 只显示符合新规则的数据
3. WHEN 新规则的数据不足 264 条时，THE 系统 SHALL 用空单元格填充
4. WHEN 新规则的数据超过 264 条时，THE 系统 SHALL 只显示最新的 264 条数据

### 需求 4：保持数据一致性

**用户故事：** 作为开发者，我希望珠盘路显示的数据与 App.tsx 中过滤后的数据保持一致，以便确保数据的准确性。

#### 验收标准

1. WHEN App.tsx 通过 WebSocket 接收新区块时，THE 系统 SHALL 验证区块是否符合当前规则
2. WHEN 区块符合规则时，THE 系统 SHALL 将其添加到 `allBlocks` 状态中
3. WHEN 区块不符合规则时，THE 系统 SHALL 跳过该区块，不添加到状态中
4. WHEN 珠盘路组件接收 `blocks` 属性时，THE 组件 SHALL 假设所有数据已经过滤，直接进行显示

### 需求 5：移除未使用的参数警告

**用户故事：** 作为开发者，我希望代码中没有未使用的参数警告，以便保持代码质量和可维护性。

#### 验收标准

1. WHEN TypeScript 编译器检查代码时，THE 编译器 SHALL 不报告 `interval` 参数未使用的警告
2. WHEN TypeScript 编译器检查代码时，THE 编译器 SHALL 不报告 `startBlock` 参数未使用的警告
3. WHEN 代码被审查时，THE 代码 SHALL 清晰地展示所有参数的用途
4. WHEN 函数被调用时，THE 函数 SHALL 正确使用所有传入的参数
