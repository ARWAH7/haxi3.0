# 前端数据保存和加载总结

## 📋 概述

前端应用使用 **后端 Redis** 作为数据存储，通过 RESTful API 进行数据的保存和加载。所有配置数据都存储在后端，前端不使用 localStorage 或 sessionStorage。

**架构**：
```
前端 (React) ←→ 后端 API (Express) ←→ Redis 数据库
```

---

## 📊 需要保存和加载的数据

### 1. 主题颜色 (ThemeColors)

**数据结构**：
```typescript
interface ThemeColors {
  odd: string;      // 单数颜色（默认：#ef4444 红色）
  even: string;     // 双数颜色（默认：#14b8a6 青色）
  big: string;      // 大数颜色（默认：#f97316 橙色）
  small: string;    // 小数颜色（默认：#6366f1 靛蓝色）
}
```

**默认值**：
```typescript
const DEFAULT_COLORS: ThemeColors = {
  odd: '#ef4444',   // red-500
  even: '#14b8a6',  // teal-500
  big: '#f97316',   // orange-500
  small: '#6366f1', // indigo-500
};
```

**API 端点**：
- **保存**：`POST /api/config/theme`
- **加载**：`GET /api/config/theme`

**保存时机**：
- 用户修改主题颜色时
- 使用防抖保存（1000ms）

**加载时机**：
- 应用启动时（组件挂载）

**使用位置**：
- 全局 CSS 变量（`--color-odd`, `--color-even`, `--color-big`, `--color-small`）
- 走势图、珠盘路、数据表格等组件

---

### 2. 采样规则 (IntervalRule[])

**数据结构**：
```typescript
interface IntervalRule {
  id: string;              // 规则 ID（唯一标识）
  label: string;           // 规则标签（显示名称）
  value: number;           // 步长（每隔多少个区块采样一次）
  startBlock: number;      // 起始偏移（从哪个区块高度开始采样）
  trendRows: number;       // 走势路行数（默认：6）
  beadRows: number;        // 珠盘路行数（默认：6）
  dragonThreshold?: number; // 长龙提醒阈值（默认：3）
}
```

**默认值**：
```typescript
const DEFAULT_RULES: IntervalRule[] = [
  { id: '1', label: '单区块', value: 1, startBlock: 0, trendRows: 6, beadRows: 6, dragonThreshold: 3 },
  { id: '20', label: '20区块', value: 20, startBlock: 0, trendRows: 6, beadRows: 6, dragonThreshold: 3 },
  { id: '60', label: '60区块', value: 60, startBlock: 0, trendRows: 6, beadRows: 6, dragonThreshold: 3 },
  { id: '100', label: '100区块', value: 100, startBlock: 0, trendRows: 6, beadRows: 6, dragonThreshold: 3 },
];
```

**API 端点**：
- **保存**：`POST /api/config/rules`
- **加载**：`GET /api/config/rules`

**保存时机**：
- 用户添加、编辑、删除规则时
- 用户批量导入规则时
- 使用防抖保存（2000ms）

**加载时机**：
- 应用启动时（组件挂载）

**使用位置**：
- 规则选择器（快速切换器）
- 设置面板（规则管理）
- 走势图、珠盘路、长龙提醒等组件（根据规则过滤数据）

---

### 3. 激活规则 ID (activeRuleId)

**数据结构**：
```typescript
string  // 当前激活的规则 ID
```

**默认值**：
```typescript
'1'  // 默认激活"单区块"规则
```

**API 端点**：
- **保存**：`POST /api/config/active-rule`
- **加载**：`GET /api/config/active-rule`

**保存时机**：
- 用户切换规则时
- 使用防抖保存（500ms）

**加载时机**：
- 应用启动时（组件挂载）

**使用位置**：
- 全局状态（决定当前使用哪个规则）
- 走势图、珠盘路、长龙提醒等组件（根据激活规则显示数据）

---

### 4. 关注模式 (FollowedPattern[])

**数据结构**：
```typescript
interface FollowedPattern {
  ruleId: string;           // 规则 ID
  type: 'parity' | 'size';  // 类型（单双或大小）
  mode: 'trend' | 'bead';   // 模式（走势路或珠盘路）
  rowId?: number;           // 行 ID（可选）
}
```

**默认值**：
```typescript
[]  // 默认无关注模式
```

**API 端点**：
- **保存**：`POST /api/config/followed-patterns`
- **加载**：`GET /api/config/followed-patterns`

**保存时机**：
- 用户添加或移除关注模式时
- 使用防抖保存（2000ms）

**加载时机**：
- 应用启动时（组件挂载）

**使用位置**：
- 长龙提醒组件（显示用户关注的模式）
- 走势图、珠盘路组件（标记关注的模式）

---

## 🔄 数据流程

### 加载流程（应用启动）

```
1. 用户打开应用
   ↓
2. App 组件挂载
   ↓
3. useEffect 触发，并行加载所有配置
   ├─ loadThemeColors()      → GET /api/config/theme
   ├─ loadRules()            → GET /api/config/rules
   ├─ loadActiveRuleId()     → GET /api/config/active-rule
   └─ loadFollowedPatterns() → GET /api/config/followed-patterns
   ↓
4. 后端从 Redis 读取数据
   ↓
5. 前端接收数据，更新状态
   ├─ setThemeColors(colors)
   ├─ setRules(rulesData)
   ├─ setActiveRuleId(activeId)
   └─ setFollowedPatterns(patterns)
   ↓
6. 如果加载失败，使用默认值
   ↓
7. 设置 isLoadingConfig = false
   ↓
8. 应用正常运行
```

### 保存流程（用户修改配置）

```
1. 用户修改配置（例如：修改主题颜色）
   ↓
2. 前端状态更新（例如：setThemeColors(newColors)）
   ↓
3. useEffect 监听状态变化
   ↓
4. 触发防抖保存函数（例如：debouncedSaveThemeColors）
   ↓
5. 等待防抖时间（1000ms）
   ↓
6. 发送 POST 请求到后端（例如：POST /api/config/theme）
   ↓
7. 后端保存数据到 Redis
   ↓
8. 返回成功响应
   ↓
9. 前端记录日志（成功或失败）
```

---

## 📁 相关文件

### 1. `services/configApi.ts`
**功能**：配置数据 API 客户端

**导出函数**：
- `saveThemeColors(colors)` - 保存主题颜色
- `loadThemeColors()` - 加载主题颜色
- `saveRules(rules)` - 保存采样规则
- `loadRules()` - 加载采样规则
- `saveActiveRuleId(ruleId)` - 保存激活规则 ID
- `loadActiveRuleId()` - 加载激活规则 ID
- `saveFollowedPatterns(patterns)` - 保存关注模式
- `loadFollowedPatterns()` - 加载关注模式
- `clearAllConfig()` - 清除所有配置
- `debouncedSaveThemeColors` - 防抖保存主题颜色（1000ms）
- `debouncedSaveRules` - 防抖保存采样规则（2000ms）
- `debouncedSaveActiveRuleId` - 防抖保存激活规则（500ms）
- `debouncedSaveFollowedPatterns` - 防抖保存关注模式（2000ms）

### 2. `App.tsx`
**功能**：主应用组件，管理全局状态

**状态管理**：
- `themeColors` - 主题颜色状态
- `rules` - 采样规则状态
- `activeRuleId` - 激活规则 ID 状态
- `followedPatterns` - 关注模式状态
- `isLoadingConfig` - 配置加载状态

**数据加载**：
- 组件挂载时并行加载所有配置
- 加载失败时使用默认值

**数据保存**：
- 监听状态变化，自动保存到后端
- 使用防抖避免频繁保存

---

## 🔧 防抖机制

### 为什么使用防抖？

1. **避免频繁请求**：用户可能快速修改配置，防抖可以减少 API 请求次数
2. **提高性能**：减少网络请求和后端压力
3. **改善用户体验**：避免每次修改都触发保存，等待用户完成修改后再保存

### 防抖时间设置

| 配置类型 | 防抖时间 | 原因 |
|---------|---------|------|
| 主题颜色 | 1000ms | 用户可能连续调整多个颜色 |
| 采样规则 | 2000ms | 规则数据较大，避免频繁保存 |
| 激活规则 | 500ms | 切换规则需要快速响应 |
| 关注模式 | 2000ms | 模式数据较大，避免频繁保存 |

---

## ⚠️ 注意事项

### 1. 配置加载状态

**问题**：如果在配置加载完成前就保存数据，会导致默认值覆盖已保存的配置。

**解决方案**：
```typescript
// 只在配置加载完成后才保存
if (!isLoadingConfig) {
  debouncedSaveThemeColors(themeColors);
}
```

### 2. 默认值处理

**问题**：如果后端没有保存的配置，前端应该使用默认值。

**解决方案**：
```typescript
if (colors) {
  setThemeColors(colors);
} else {
  // 使用默认值（已在 useState 中设置）
}
```

### 3. 错误处理

**问题**：如果 API 请求失败，应该如何处理？

**解决方案**：
```typescript
try {
  const response = await fetch(...);
  // 处理响应
} catch (error) {
  console.error('[配置API] 加载失败:', error);
  return null;  // 返回 null，前端使用默认值
}
```

### 4. 并行加载

**问题**：如果串行加载配置，会导致加载时间过长。

**解决方案**：
```typescript
// 并行加载所有配置
const [colors, rulesData, activeId, patterns] = await Promise.all([
  loadThemeColors(),
  loadRules(),
  loadActiveRuleId(),
  loadFollowedPatterns()
]);
```

---

## 📊 数据存储位置

### 后端 Redis

**存储键**：
- `config:theme` - 主题颜色
- `config:rules` - 采样规则
- `config:active-rule` - 激活规则 ID
- `config:followed-patterns` - 关注模式

**数据格式**：JSON 字符串

**优势**：
1. **持久化**：数据不会因为浏览器关闭而丢失
2. **跨设备同步**：可以在不同设备上使用相同的配置
3. **集中管理**：所有配置数据集中存储在后端
4. **备份和恢复**：可以轻松备份和恢复配置数据

---

## 🚀 未来优化建议

### 1. 配置版本管理

**问题**：如果配置数据结构发生变化，旧数据可能不兼容。

**建议**：
- 添加配置版本号
- 实现数据迁移逻辑
- 自动升级旧版本配置

### 2. 配置导入/导出

**问题**：用户可能希望备份或分享配置。

**建议**：
- 添加导出配置功能（JSON 文件）
- 添加导入配置功能（从 JSON 文件）
- 支持配置模板

### 3. 配置同步状态

**问题**：用户不知道配置是否已保存。

**建议**：
- 添加保存状态指示器（保存中、已保存、保存失败）
- 显示最后保存时间
- 添加手动保存按钮

### 4. 离线支持

**问题**：如果后端不可用，应用无法加载配置。

**建议**：
- 使用 localStorage 作为缓存
- 离线时使用缓存数据
- 在线时同步到后端

---

## 📝 总结

### 当前数据保存和加载机制

✅ **优点**：
1. 所有配置数据集中存储在后端 Redis
2. 使用防抖机制避免频繁保存
3. 并行加载配置，提高加载速度
4. 错误处理完善，加载失败时使用默认值
5. 配置加载状态管理，避免默认值覆盖已保存配置

⚠️ **注意事项**：
1. 需要后端服务正常运行
2. 需要 Redis 数据库正常运行
3. 网络请求可能失败，需要错误处理
4. 防抖时间需要根据实际情况调整

### 数据清单

| 数据类型 | 数据结构 | API 端点 | 防抖时间 | 默认值 |
|---------|---------|---------|---------|--------|
| 主题颜色 | ThemeColors | /api/config/theme | 1000ms | DEFAULT_COLORS |
| 采样规则 | IntervalRule[] | /api/config/rules | 2000ms | DEFAULT_RULES |
| 激活规则 ID | string | /api/config/active-rule | 500ms | '1' |
| 关注模式 | FollowedPattern[] | /api/config/followed-patterns | 2000ms | [] |

---

**文档创建时间**：2026-02-07  
**最后更新时间**：2026-02-07  
**文档版本**：1.0
