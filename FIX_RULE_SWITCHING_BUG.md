# 🔧 修复：规则切换显示相同数据的问题

## 问题描述

**现象**：
- 3秒（步长1）显示正常
- 6秒（步长2）、9秒（步长3）、15秒（步长5）等所有其他规则都显示 3秒（步长1）的数据

## 根本原因

### 原因1：规则切换时不重新加载数据

**位置**：`App.tsx` - 规则变化 useEffect（第 388-405 行）

**问题代码**：
```typescript
// 修改前：检查数据量，如果足够就不重新加载
if (allBlocks.length < requiredFiltered * 0.9) {
  loadHistoryBlocks(false);  // 只有数据不足时才加载
} else {
  console.log('数据已足够，无需加载');  // ❌ 错误！
}
```

**问题分析**：
- 当从规则1（步长1）切换到规则2（步长2）时
- `allBlocks` 中存储的是规则1的 264 条数据
- 检查发现 `allBlocks.length = 264 >= 237`（264 * 0.9）
- 认为"数据已足够"，不重新加载
- 结果：规则2 显示的还是规则1 的数据 ❌

**正确逻辑**：
- 切换规则时，`allBlocks` 中的数据是**上一个规则**的数据
- 必须**强制重新加载**当前规则的数据
- 不能根据数据量判断是否需要加载

### 原因2：calculateBeadGrid 使用数组索引

**位置**：`utils/helpers.ts` - `calculateBeadGrid` 函数

**修改后的代码**：
```typescript
// 使用数组索引，不考虑区块高度
const indexedBlocks = chronological.map((b, i) => ({
  block: b,
  idx: i  // 直接使用数组索引
}));
```

**影响**：
- 这个修改本身是正确的（解决了 132 显示问题）
- 但它依赖于前端传入的数据是**正确过滤后的数据**
- 如果前端传入错误的数据（如规则1的数据），就会显示错误

## 修复内容

### 修复1：强制重新加载数据

**文件**：`App.tsx`

**修改**：
```typescript
// 修改前
if (allBlocks.length < requiredFiltered * 0.9) {
  loadHistoryBlocks(false);
} else {
  console.log('数据已足够，无需加载');
}

// 修改后
console.log(`[规则变化] 切换到规则: ${activeRule.label} (步长 ${activeRule.value})，强制重新加载数据`);
loadHistoryBlocks(true);  // ✅ 强制重新加载
```

**原理**：
- 切换规则时，总是调用 `loadHistoryBlocks(true)`
- `forceReload = true` 会跳过数据量检查
- 确保每次切换规则都重新从后端加载正确的数据

### 修复2：保留 forceReload 检查

**文件**：`App.tsx` - `loadHistoryBlocks` 函数

**代码**：
```typescript
// ✅ 如果是强制重新加载，跳过数据量检查
if (!forceReload && allBlocks.length >= requiredFiltered * 0.9) {
  console.log(`[API] 数据已足够，跳过加载`);
  return;
}
```

**原理**：
- 只有在 `forceReload = false` 时才检查数据量
- 规则切换时使用 `forceReload = true`，跳过检查
- 确保强制重新加载能够正常工作

## 测试步骤

### 1. 刷新页面
按 **Ctrl+F5** 强制刷新浏览器。

### 2. 测试规则切换

#### 测试A：切换到步长2
1. 切换到 "6秒（步长2）" 规则
2. 查看 Console 日志：
   ```
   [规则变化] 切换到规则: 6秒 (步长 2)，强制重新加载数据
   [API] 🚀 正在从后端加载过滤后的数据...
   [API] 规则: 6秒, 步长: 2, 偏移: 0, 需要: 264 条
   [API] ✅ 后端过滤完成: 返回 264 条数据
   ```
3. 查看珠盘路，应该显示步长2的数据（区块高度间隔为2）

#### 测试B：切换到步长10
1. 切换到 "30秒（步长10）" 规则
2. 查看 Console 日志：
   ```
   [规则变化] 切换到规则: 30秒 (步长 10)，强制重新加载数据
   [API] 🚀 正在从后端加载过滤后的数据...
   [API] 规则: 30秒, 步长: 10, 偏移: 0, 需要: 264 条
   [API] ✅ 后端过滤完成: 返回 264 条数据
   ```
3. 查看珠盘路，应该显示步长10的数据（区块高度间隔为10）

#### 测试C：验证数据不同
1. 切换到 "3秒（步长1）"，记录第一个区块高度
2. 切换到 "6秒（步长2）"，记录第一个区块高度
3. 两个高度应该不同（步长2的高度应该是偶数）

### 3. 使用调试命令验证

```javascript
// 切换到步长1
window.debugApp.printDebugInfo()
// 记录输出

// 切换到步长2
window.debugApp.printDebugInfo()
// 记录输出，应该不同

// 查看区块高度
window.debugApp.allBlocks.slice(0, 5).map(b => b.height)
// 步长1: [100, 99, 98, 97, 96]
// 步长2: [100, 98, 96, 94, 92]
```

## 预期结果

### Console 日志
每次切换规则时，应该看到：
```
[规则变化] 切换到规则: XXX (步长 Y)，强制重新加载数据
[API] 🚀 正在从后端加载过滤后的数据...
[API] 规则: XXX, 步长: Y, 偏移: 0, 需要: 264 条
[API] ✅ 后端过滤完成: 返回 264 条数据
```

### 数据验证
- 步长1：区块高度连续（100, 99, 98, 97, ...）
- 步长2：区块高度间隔2（100, 98, 96, 94, ...）
- 步长10：区块高度间隔10（100, 90, 80, 70, ...）

### 珠盘路显示
- 每个规则显示的数据应该不同
- 步长越大，数据跨度越大
- 不应该所有规则都显示相同的数据

## 性能影响

### 优点
- ✅ 确保数据正确性
- ✅ 每次切换规则都加载正确的数据

### 缺点
- ⚠️ 每次切换规则都会发起 API 请求
- ⚠️ 可能增加网络流量

### 优化建议（未来）
可以考虑：
1. **缓存机制**：为每个规则缓存数据
2. **智能判断**：检查 `allBlocks` 中的数据是否符合当前规则
3. **预加载**：提前加载常用规则的数据

但目前优先保证正确性，性能优化可以后续进行。

## 如果问题仍然存在

### 检查1：Console 日志
切换规则时，是否看到 "强制重新加载数据" 日志？

**如果没有**：
- 清除浏览器缓存（Ctrl+Shift+Delete）
- 强制刷新（Ctrl+F5）

### 检查2：后端日志
后端是否收到不同的 `ruleValue` 参数？

**查看后端 Console**：
```
[API] 📥 规则过滤请求: 步长 2, 偏移 0, 需要 264 条过滤后数据
[API] 🔍 limit 参数: 264, 类型: number
```

**如果步长始终是1**：
- 前端没有正确传递 `ruleValue` 参数
- 检查 `loadHistoryBlocks` 函数

### 检查3：数据验证
```javascript
// 查看前5个区块的高度
window.debugApp.allBlocks.slice(0, 5).map(b => b.height)
```

**步长1**：应该是连续的（如 [100, 99, 98, 97, 96]）
**步长2**：应该间隔2（如 [100, 98, 96, 94, 92]）

---

**修复时间**：2026-02-06
**状态**：✅ 修复完成，等待测试
**预期结果**：每个规则显示不同的数据
