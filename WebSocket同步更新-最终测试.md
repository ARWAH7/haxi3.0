# WebSocket 同步更新 - 最终测试

## 正确实现

### 核心逻辑
WebSocket 推送原始区块时，检查每个已缓存规则的步长，只有符合步长的区块才添加到对应规则的缓存。

### 示例

**WebSocket 推送区块：79928513**

- **规则 A（步长1）**：79928513 % 1 === 0 ✅ → 添加
- **规则 B（步长2）**：79928513 % 2 === 1 ❌ → 不添加
- **规则 C（步长3）**：79928513 % 3 === 2 ❌ → 不添加

**WebSocket 推送区块：79928514**

- **规则 A（步长1）**：79928514 % 1 === 0 ✅ → 添加
- **规则 B（步长2）**：79928514 % 2 === 0 ✅ → 添加
- **规则 C（步长3）**：79928514 % 3 === 1 ❌ → 不添加

**WebSocket 推送区块：79928515**

- **规则 A（步长1）**：79928515 % 1 === 0 ✅ → 添加
- **规则 B（步长2）**：79928515 % 2 === 1 ❌ → 不添加
- **规则 C（步长3）**：79928515 % 3 === 0 ✅ → 添加

## 测试步骤

### 测试1：基本同步更新

#### 操作步骤：
1. 打开浏览器控制台（F12）
2. 切换到规则 A（3秒，步长1）
3. 切换到规则 B（6秒，步长2）
4. 切换到规则 C（9秒，步长3）
5. 确保所有规则都已缓存
6. 切换回规则 A
7. 等待 5-10 秒，观察 WebSocket 推送

#### 预期结果：
```
[Redis WS] 📦 新区块: 79928513 (odd, big)
[WebSocket] ✅ 添加新区块: 79928513, 当前总数: 264
[缓存] 🔄 同步更新规则 1-0 的缓存（新区块: 79928513，符合步长 1）
[缓存] ⏭️ 区块 79928513 不符合规则 2-0 的步长 2，跳过
[缓存] ⏭️ 区块 79928513 不符合规则 3-0 的步长 3，跳过

[Redis WS] 📦 新区块: 79928514 (even, big)
[WebSocket] ✅ 添加新区块: 79928514, 当前总数: 264
[缓存] 🔄 同步更新规则 1-0 的缓存（新区块: 79928514，符合步长 1）
[缓存] 🔄 同步更新规则 2-0 的缓存（新区块: 79928514，符合步长 2）
[缓存] ⏭️ 区块 79928514 不符合规则 3-0 的步长 3，跳过

[Redis WS] 📦 新区块: 79928515 (odd, small)
[WebSocket] ✅ 添加新区块: 79928515, 当前总数: 264
[缓存] 🔄 同步更新规则 1-0 的缓存（新区块: 79928515，符合步长 1）
[缓存] ⏭️ 区块 79928515 不符合规则 2-0 的步长 2，跳过
[缓存] 🔄 同步更新规则 3-0 的缓存（新区块: 79928515，符合步长 3）
```

#### 验证点：
- ✅ 步长1的规则：所有区块都更新
- ✅ 步长2的规则：只有偶数区块更新
- ✅ 步长3的规则：只有3的倍数更新

### 测试2：规则切换数据连续性

#### 操作步骤：
1. 切换到规则 A（步长1）
2. 等待数据加载完成
3. 切换到规则 B（步长2）
4. 等待 5 秒（让 WebSocket 推送几个新区块）
5. **切换回规则 A**

#### 预期结果（缓存未过期）：
```
[缓存] ✅ 使用缓存数据: 264 条 (规则: 3秒, 缓存年龄: 6.5秒)
```

**数据显示**：
- 79928515, 79928514, 79928513, 79928512, ...（连续）✅
- 不会出现：79928515, 79928512, 79928509, ...（跳跃）❌

#### 预期结果（缓存已过期）：
```
[缓存] ⏰ 缓存已过期 (12.3秒)，重新加载
[API] 🚀 正在从后端加载过滤后的数据...
[API] ✅ 后端加载完成: 264 条
```

**数据显示**：
- 79928520, 79928519, 79928518, ...（最新且连续）✅

### 测试3：不同步长规则的独立性

#### 操作步骤：
1. 切换到规则 A（步长1）
2. 切换到规则 B（步长2）
3. 切换到规则 C（步长3）
4. 确保所有规则都已缓存
5. 切换回规则 A
6. 等待 WebSocket 推送 6 个新区块
7. 依次切换到规则 B、C，检查数据

#### 预期结果：

**规则 A（步长1）**：
- 数据：79928520, 79928519, 79928518, 79928517, 79928516, 79928515, ...
- 新增：6 个区块 ✅

**规则 B（步长2）**：
- 数据：79928520, 79928518, 79928516, 79928514, ...
- 新增：3 个区块（偶数）✅

**规则 C（步长3）**：
- 数据：79928520, 79928517, 79928514, 79928511, ...
- 新增：2 个区块（3的倍数）✅

#### 验证点：
- ✅ 每个规则的缓存独立维护
- ✅ 只有符合步长的区块被添加
- ✅ 数据连续，无跳跃

### 测试4：缓存过期机制

#### 操作步骤：
1. 切换到规则 A
2. 等待数据加载完成
3. 切换到规则 B
4. **等待 15 秒**（超过 10 秒过期时间）
5. 切换回规则 A

#### 预期结果：
```
[缓存] ⏰ 缓存已过期 (15.2秒)，重新加载
[API] 🚀 正在从后端加载过滤后的数据...
[API] ✅ 后端加载完成: 264 条
```

#### 验证点：
- ✅ 缓存过期后自动重新加载
- ✅ 数据是最新的
- ✅ 数据连续，无断层

## 调试工具

### 1. 查看所有缓存的规则
```javascript
console.log('缓存规则:', Array.from(window.debugApp.blocksCache.keys()));
```

### 2. 查看每个规则的缓存详情
```javascript
window.debugApp.blocksCache.forEach((entry, key) => {
  const age = (Date.now() - entry.timestamp) / 1000;
  console.log(`规则 ${key}:`);
  console.log(`  - 数据量: ${entry.data.length} 条`);
  console.log(`  - 缓存年龄: ${age.toFixed(1)}秒`);
  console.log(`  - 最新区块: ${entry.data[0]?.height}`);
  console.log(`  - 最旧区块: ${entry.data[entry.data.length - 1]?.height}`);
});
```

### 3. 验证步长正确性
```javascript
// 检查规则 B（步长2）的缓存
const rule2Cache = window.debugApp.blocksCache.get('2-0');
if (rule2Cache) {
  const heights = rule2Cache.data.map(b => b.height);
  const allEven = heights.every(h => h % 2 === 0);
  console.log('规则 B（步长2）所有区块都是偶数:', allEven);
}

// 检查规则 C（步长3）的缓存
const rule3Cache = window.debugApp.blocksCache.get('3-0');
if (rule3Cache) {
  const heights = rule3Cache.data.map(b => b.height);
  const allMultipleOf3 = heights.every(h => h % 3 === 0);
  console.log('规则 C（步长3）所有区块都是3的倍数:', allMultipleOf3);
}
```

## 常见问题

### Q1: 为什么有时候还是会看到数据跳跃？
**A**: 可能的原因：
1. **缓存已过期**（> 10秒）：会自动重新加载，数据是最新的
2. **首次切换到某个规则**：没有缓存，需要从后端加载
3. **WebSocket 连接断开**：没有收到新区块推送

**解决方法**：
- 检查控制台日志，确认缓存状态
- 检查 WebSocket 连接状态
- 如果缓存过期，这是正常的（会自动重新加载）

### Q2: 如何确认同步更新是否正常工作？
**A**: 观察控制台日志：
```
[缓存] 🔄 同步更新规则 1-0 的缓存（新区块: 79928515，符合步长 1）
[缓存] 🔄 同步更新规则 3-0 的缓存（新区块: 79928515，符合步长 3）
```

如果看到这些日志，说明同步更新正常工作。

### Q3: 缓存过期时间为什么是10秒？
**A**: 10秒是一个平衡点：
- **太短**（<5秒）：频繁重新加载，影响性能
- **太长**（>30秒）：可能出现数据断层
- **10秒**：既保证性能，又保证数据连续性

大多数用户的规则切换频率 < 10秒，所以缓存仍然有效。

## 验证清单

- [ ] WebSocket 推送时，所有规则的缓存都正确更新
- [ ] 步长1的规则：所有区块都添加
- [ ] 步长2的规则：只有偶数区块添加
- [ ] 步长3的规则：只有3的倍数添加
- [ ] 规则切换数据连续，无跳跃
- [ ] 缓存过期后自动重新加载
- [ ] 控制台日志显示正确的同步更新信息

## 总结

通过正确实现 WebSocket 同步更新逻辑，我们实现了：

1. **实时性**：所有规则的缓存实时更新
2. **准确性**：只有符合步长的区块才添加到缓存
3. **独立性**：每个规则的缓存独立维护
4. **兜底机制**：缓存过期后自动重新加载

**核心价值**：
- ✅ 规则切换快速（使用缓存）
- ✅ 数据始终最新（WebSocket 同步）
- ✅ 数据始终连续（缓存过期重新加载）
- ✅ 性能和准确性的完美平衡

现在，无论如何切换规则，数据都应该是连续且最新的！🎉
