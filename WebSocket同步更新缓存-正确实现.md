# WebSocket 同步更新缓存 - 正确实现

## 关键理解

### 用户指出的关键点
> "WebSocket 可以同步更新其他规则缓存，但前提是符合规则步长的可以加缓存，不同规则步长数据不同。"

### 正确理解

1. **WebSocket 推送的是原始区块**（未过滤）
   - 每个新区块都会推送
   - 不是基于当前规则过滤的

2. **每个规则有自己的步长要求**
   - 步长1：所有区块（1, 2, 3, 4, 5, ...）
   - 步长2：偶数区块（2, 4, 6, 8, 10, ...）
   - 步长3：3的倍数（3, 6, 9, 12, 15, ...）

3. **同步更新的正确逻辑**
   - 检查新区块是否符合每个规则的步长
   - 只有符合的才添加到对应规则的缓存
   - 不符合的不添加

## 之前的错误

### 错误1：误以为 WebSocket 推送的是过滤后的数据
```typescript
// ❌ 错误理解
// 以为在规则 B（步长3）时，WebSocket 只推送步长3的区块
// 实际上：WebSocket 推送所有新区块
```

### 错误2：禁用了同步更新
```typescript
// ❌ 错误修复
// 完全禁用了同步更新其他规则的缓存
// 导致其他规则的缓存永远不会更新
```

## 正确实现

### 核心逻辑

```typescript
// ✅ 正确实现
setBlocksCache(prevCache => {
  const newCache = new Map(prevCache);
  const now = Date.now();
  
  // 遍历所有已缓存的规则
  Array.from(newCache.entries()).forEach(([cacheKey, cacheEntry]) => {
    // 解析规则参数
    const [ruleValue, startBlock] = cacheKey.split('-').map(Number);
    
    // 检查新区块是否符合这个规则的步长
    let isAligned = false;
    if (ruleValue <= 1) {
      // 步长1：所有区块都符合
      isAligned = true;
    } else if (startBlock > 0) {
      // 有起始偏移
      isAligned = block.height >= startBlock && 
                  (block.height - startBlock) % ruleValue === 0;
    } else {
      // 无起始偏移
      isAligned = block.height % ruleValue === 0;
    }
    
    // 只有符合规则步长的区块才添加到缓存
    if (isAligned) {
      const cachedData = cacheEntry.data;
      // 检查是否已存在
      if (!cachedData.some(b => b.height === block.height)) {
        const updatedCache = [block, ...cachedData].slice(0, 264);
        newCache.set(cacheKey, {
          data: updatedCache,
          timestamp: now
        });
      }
    }
  });
  
  return newCache;
});
```

### 示例场景

**假设 WebSocket 推送区块：79928513**

1. **规则 A（步长1，偏移0）**
   - 检查：79928513 % 1 === 0 ✅
   - 结果：添加到缓存

2. **规则 B（步长2，偏移0）**
   - 检查：79928513 % 2 === 1 ❌
   - 结果：不添加到缓存

3. **规则 C（步长3，偏移0）**
   - 检查：79928513 % 3 === 2 ❌
   - 结果：不添加到缓存

**假设 WebSocket 推送区块：79928514**

1. **规则 A（步长1，偏移0）**
   - 检查：79928514 % 1 === 0 ✅
   - 结果：添加到缓存

2. **规则 B（步长2，偏移0）**
   - 检查：79928514 % 2 === 0 ✅
   - 结果：添加到缓存

3. **规则 C（步长3，偏移0）**
   - 检查：79928514 % 3 === 1 ❌
   - 结果：不添加到缓存

**假设 WebSocket 推送区块：79928515**

1. **规则 A（步长1，偏移0）**
   - 检查：79928515 % 1 === 0 ✅
   - 结果：添加到缓存

2. **规则 B（步长2，偏移0）**
   - 检查：79928515 % 2 === 1 ❌
   - 结果：不添加到缓存

3. **规则 C（步长3，偏移0）**
   - 检查：79928515 % 3 === 0 ✅
   - 结果：添加到缓存

## 为什么之前会出现问题？

### 问题场景重现

1. **用户在规则 A（步长1）**
   - 缓存：79928510, 79928511, 79928512, 79928513, ...

2. **切换到规则 B（步长3）**
   - 从后端加载：79928512, 79928515, 79928518, ...
   - 建立缓存

3. **WebSocket 推送：79928519**
   - 检查规则 A（步长1）：79928519 % 1 === 0 ✅
   - ❌ **之前的错误**：直接添加 79928519 到规则 A 的缓存
   - 规则 A 缓存变成：79928519, 79928510, 79928511, 79928512, 79928513, ...
   - 问题：缺少 79928514-79928518

4. **WebSocket 推送：79928520**
   - 检查规则 A（步长1）：79928520 % 1 === 0 ✅
   - 添加到规则 A 的缓存
   - 规则 A 缓存：79928520, 79928519, 79928510, 79928511, ...
   - 问题：数据不连续

### 根本原因

**问题不在于同步更新本身，而在于：**
- 当用户切换到规则 B 时，规则 A 的缓存已经过时
- WebSocket 只能推送新区块，无法填补中间缺失的区块
- 所以规则 A 的缓存会出现断层

## 正确的解决方案

### 方案：缓存过期机制 + 同步更新

1. **缓存过期机制**（10秒）
   - 如果缓存超过10秒，强制重新加载
   - 确保数据连续性

2. **同步更新**
   - WebSocket 推送时，更新所有符合规则的缓存
   - 保持缓存实时性

3. **组合效果**
   - 如果用户在10秒内切换回来：使用缓存（快速）
   - 如果超过10秒：重新加载（准确）
   - WebSocket 推送：保持缓存最新

## 实施步骤

1. **恢复同步更新逻辑**
   - 重新添加遍历所有规则的代码
   - 正确判断区块是否符合规则步长

2. **保留缓存过期机制**
   - 10秒过期时间
   - 作为兜底机制

3. **添加调试日志**
   - 显示哪些规则的缓存被更新
   - 方便排查问题
