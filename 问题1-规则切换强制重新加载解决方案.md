# 问题 1：每次切换规则都重新加载数据 - 解决方案

## 📋 问题描述

### 问题表现
每次切换规则时，前端都会强制从后端重新加载数据，即使数据已经在前端存在。

### 问题位置
**文件**：`App.tsx` - 规则变化监听

```typescript
// 规则变化时检查是否需要重新加载数据（使用防抖）
useEffect(() => {
  if (!wsConnected || !activeRule) return;
  
  // 使用防抖避免频繁切换时重复加载
  const timer = setTimeout(() => {
    // ❌ 问题：切换规则时，强制重新加载数据
    console.log(`[规则变化] 切换到规则: ${activeRule.label} (步长 ${activeRule.value})，强制重新加载数据`);
    loadHistoryBlocks(true);  // 强制重新加载
  }, 300); // 300ms 防抖
  
  return () => clearTimeout(timer);
}, [activeRuleId, wsConnected]); // 只监听规则ID变化，避免频繁重载
```

### 问题分析
1. **强制重新加载**：每次切换规则都调用 `loadHistoryBlocks(true)`，参数 `true` 表示强制重新加载
2. **忽略现有数据**：即使前端已经有数据，也要从后端重新请求
3. **用户体验差**：每次切换都有明显的加载延迟（~500ms）
4. **资源浪费**：重复加载相同的数据，浪费网络带宽和服务器资源

---

## 🔧 解决方案

### 方案概述
**核心思路**：实现前端数据缓存机制，切换规则时优先使用缓存数据，只在缓存不足时才从后端加载。

### 实施步骤

#### 步骤 1：添加数据缓存状态

在 `App.tsx` 中添加缓存状态：

```typescript
// 数据缓存：key 为 "步长-偏移"，value 为该规则的区块数据
const [blocksCache, setBlocksCache] = useState<Map<string, BlockData[]>>(new Map());
```

**说明**：
- 使用 `Map` 数据结构存储缓存
- 缓存键格式：`${ruleValue}-${startBlock}`（例如：`"1-0"`, `"20-0"`, `"60-0"`）
- 缓存值：符合该规则的区块数据数组

**缓存规则**：
1. ✅ **只缓存符合规则步长的数据**：不符合规则步长的数据不保存到缓存
2. ✅ **固定大小**：每个规则缓存最多 264 条符合规则的最新数据
3. ✅ **自动更新**：有新数据时，删除最旧的数据，保持 264 条
4. ✅ **已排序**：按 height 降序排列（最新的在前）

**示例**：
```typescript
// 3秒规则（步长 1）的缓存
cacheKey = "1-0"
cacheValue = [符合步长1的264条最新数据]

// 1分钟规则（步长 20）的缓存
cacheKey = "20-0"
cacheValue = [符合步长20的264条最新数据]

// 5分钟规则（步长 100）的缓存
cacheKey = "100-0"
cacheValue = [符合步长100的264条最新数据]
```

---

#### 步骤 2：修改 loadHistoryBlocks 函数

在 `loadHistoryBlocks` 函数开头添加缓存检查逻辑：

```typescript
const loadHistoryBlocks = useCallback(async (forceReload: boolean = false) => {
  try {
    const ruleValue = activeRule?.value || 1;
    const startBlock = activeRule?.startBlock || 0;
    const requiredFiltered = requiredDataCount;
    const cacheKey = `${ruleValue}-${startBlock}`;
    
    // ✅ 优先使用缓存数据
    if (!forceReload && blocksCache.has(cacheKey)) {
      const cachedData = blocksCache.get(cacheKey)!;
      if (cachedData.length >= requiredFiltered * 0.9) {
        console.log(`[缓存] ✅ 使用缓存数据: ${cachedData.length} 条 (规则: ${activeRule?.label})`);
        setAllBlocks(cachedData);
        setIsLoading(false);
        return;
      }
    }
    
    // ✅ 缓存不足，从后端加载
    setIsLoading(true);
    
    // ... 现有的加载逻辑 ...
    
    if (result.success) {
      setAllBlocks(result.data);
      
      // ✅ 更新缓存
      setBlocksCache(prev => {
        const newCache = new Map(prev);
        newCache.set(cacheKey, result.data);
        
        // ✅ 限制缓存大小（最多保留 10 个规则的数据）
        if (newCache.size > 10) {
          const firstKey = newCache.keys().next().value;
          newCache.delete(firstKey);
        }
        
        return newCache;
      });
      
      console.log(`[API] ✅ 后端过滤完成: 返回 ${result.data.length} 条数据`);
      console.log(`[缓存] 💾 已缓存规则: ${cacheKey}`);
    }
    
    setIsLoading(false);
  } catch (error) {
    console.error('[API] 加载历史数据失败:', error);
    setIsLoading(false);
  }
}, [activeRule, requiredDataCount, blocksCache]);
```

**关键改动**：
1. **缓存检查**：在加载前检查缓存是否存在且数据充足
2. **缓存命中**：如果缓存命中，直接使用缓存数据，跳过网络请求
3. **缓存更新**：加载成功后，将数据存入缓存
4. **缓存限制**：最多保留 10 个规则的缓存，防止内存占用过大

---

#### 步骤 3：修改规则变化监听

修改规则变化时的加载逻辑：

```typescript
// 规则变化时检查是否需要重新加载数据
useEffect(() => {
  if (!wsConnected || !activeRule) return;
  
  // ✅ 不使用防抖，立即切换
  // 因为有缓存机制，切换速度很快
  console.log(`[规则变化] 切换到规则: ${activeRule.label} (步长 ${activeRule.value})`);
  loadHistoryBlocks(false);  // ✅ 不强制重新加载，优先使用缓存
}, [activeRuleId, wsConnected, loadHistoryBlocks]);
```

**关键改动**：
1. **移除防抖**：因为有缓存机制，切换速度很快，不需要防抖
2. **不强制重新加载**：将 `loadHistoryBlocks(true)` 改为 `loadHistoryBlocks(false)`
3. **优先使用缓存**：让 `loadHistoryBlocks` 函数自己决定是使用缓存还是加载数据

---

#### 步骤 4：WebSocket 数据更新时同步缓存

在 WebSocket 接收新区块后，同步更新缓存：

```typescript
setAllBlocks(prev => {
  // ... 现有的数据更新逻辑 ...
  
  // ✅ 任务2.1: 检查是否已存在（去重）
  if (prev.some(b => b.height === block.height)) {
    return prev;
  }
  
  // ✅ 任务2.2: 验证区块是否符合规则
  const currentRule = activeRuleRef.current;
  if (currentRule && currentRule.value > 1) {
    let isAligned = false;
    if (currentRule.startBlock > 0) {
      isAligned = block.height >= currentRule.startBlock && 
                  (block.height - currentRule.startBlock) % currentRule.value === 0;
    } else {
      isAligned = block.height % currentRule.value === 0;
    }
    
    // ❌ 不符合规则，不添加到数据中，也不缓存
    if (!isAligned) {
      return prev;
    }
  }
  
  // ✅ 任务2.3: 添加新区块到数组开头
  const combined = [block, ...prev];
  
  // ✅ 任务2.4: 去重并排序
  const uniqueBlocks = Array.from(new Map(combined.map(b => [b.height, b])).values());
  const sorted = uniqueBlocks.sort((a, b) => b.height - a.height);
  
  // ✅ 任务2.5: 保持固定大小（264 条）
  const MAX_BLOCKS_CAPACITY = 264;
  let updated = sorted;
  if (sorted.length > MAX_BLOCKS_CAPACITY) {
    updated = sorted.slice(0, MAX_BLOCKS_CAPACITY);
  }
  
  // ✅ 同步更新缓存
  if (currentRule) {
    const cacheKey = `${currentRule.value}-${currentRule.startBlock}`;
    setBlocksCache(prevCache => {
      const newCache = new Map(prevCache);
      newCache.set(cacheKey, updated);  // 缓存的是符合规则的 264 条最新数据
      return newCache;
    });
    
    if (process.env.NODE_ENV === 'development') {
      console.log(`[缓存] 💾 已同步缓存: ${cacheKey}, 数据量: ${updated.length} 条`);
    }
  }
  
  return updated;
});
```

**关键点**：
1. **只缓存符合规则的数据**：不符合规则步长的区块不会被添加到缓存
2. **固定大小**：缓存始终保持 264 条数据
3. **自动更新**：新数据到达时，自动删除最旧的数据
4. **实时同步**：WebSocket 更新数据时，同步更新缓存

---

## 📊 修复效果

### 修复前
| 操作 | 耗时 | 说明 |
|------|------|------|
| 切换规则（首次） | ~500ms | 从后端加载数据 |
| 切换回已访问规则 | ~500ms | 重新加载数据 |
| 频繁切换规则 | ~500ms × N | 每次都重新加载 |

### 修复后
| 操作 | 耗时 | 说明 |
|------|------|------|
| 切换规则（首次） | ~500ms | 从后端加载数据 |
| 切换回已访问规则 | ~10ms | 使用缓存数据 |
| 频繁切换规则 | ~10ms | 使用缓存数据 |

**性能提升**：
- 缓存命中时：**50 倍**性能提升（500ms → 10ms）
- 用户体验：切换规则几乎无延迟

---

## ⚠️ 注意事项

### 1. 缓存大小限制

**问题**：缓存太多规则的数据会占用大量内存。

**解决方案**：
- 限制缓存大小（最多 10 个规则）
- 使用 FIFO（先进先出）策略清理缓存
- 当缓存超过 10 个时，删除最早的缓存

```typescript
if (newCache.size > 10) {
  const firstKey = newCache.keys().next().value;
  newCache.delete(firstKey);
}
```

### 2. 缓存失效

**问题**：WebSocket 接收新数据时，缓存可能过期。

**解决方案**：
- WebSocket 数据更新时，同步更新当前规则的缓存
- 确保缓存数据始终是最新的

### 3. 内存占用估算

**单个规则的内存占用**：
- 264 条区块数据
- 每条区块约 0.5KB
- 单个规则约 132KB

**10 个规则的内存占用**：
- 10 × 132KB = 1.32MB
- 对于现代浏览器来说，这是可接受的内存占用

### 4. 缓存键设计

**缓存键格式**：`${ruleValue}-${startBlock}`

**示例**：
- 规则 "单区块"（步长 1，偏移 0）：缓存键 = `"1-0"`
- 规则 "20区块"（步长 20，偏移 0）：缓存键 = `"20-0"`
- 规则 "60区块"（步长 60，偏移 100）：缓存键 = `"60-100"`

**唯一性保证**：
- 不同的步长和偏移组合会生成不同的缓存键
- 确保每个规则有独立的缓存

---

## 🚀 实施建议

### 优先级：高

**原因**：
1. 用户体验影响最大
2. 实施简单，风险低
3. 性能提升明显（50 倍）

### 实施顺序

1. **第一步**：添加 `blocksCache` 状态
2. **第二步**：修改 `loadHistoryBlocks` 函数，添加缓存逻辑
3. **第三步**：修改规则变化监听，移除强制重新加载
4. **第四步**：修改 WebSocket 数据更新，同步缓存
5. **第五步**：测试缓存功能

### 测试要点

1. **缓存命中测试**：
   - 切换到规则 A → 切换到规则 B → 切换回规则 A
   - 验证：第二次切换到规则 A 时，应该使用缓存数据（~10ms）

2. **缓存更新测试**：
   - 切换到规则 A → WebSocket 接收新区块 → 切换到规则 B → 切换回规则 A
   - 验证：规则 A 的缓存应该包含新区块

3. **缓存限制测试**：
   - 连续切换 15 个不同的规则
   - 验证：缓存大小不超过 10 个

4. **内存占用测试**：
   - 使用 Chrome DevTools 的 Memory Profiler
   - 验证：缓存占用内存在合理范围内（< 2MB）

---

## 📝 总结

### 问题根源
每次切换规则都强制从后端重新加载数据，没有利用已加载的数据。

### 解决方案
实现前端数据缓存机制，切换规则时优先使用缓存数据。

### 预期效果
- **缓存命中时**：50 倍性能提升（500ms → 10ms）
- **用户体验**：切换规则几乎无延迟
- **资源节省**：减少不必要的网络请求和服务器负载

---

**文档创建时间**：2026-02-07  
**文档版本**：1.0
