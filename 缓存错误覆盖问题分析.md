# 缓存错误覆盖问题分析

## 问题现象
- 3秒（步长1）规则切换到其他规则再切回来
- 数据显示：79928512、79928515、79928518
- 这是步长3的数据，不是步长1的数据

## 根本原因

### 问题：WebSocket 同步更新缓存时的逻辑错误

当前实现中，WebSocket 推送新区块时会同步更新所有规则的缓存。但是有一个严重的问题：

```typescript
// 当前实现（有问题）
Array.from(newCache.entries()).forEach(([cacheKey, cacheEntry]) => {
  const [ruleValue, startBlock] = cacheKey.split('-').map(Number);
  
  // 检查新区块是否符合这个规则
  if (isAligned) {
    // ❌ 问题：直接添加新区块到缓存
    const updatedCache = [block, ...cacheEntry.data].slice(0, 264);
    newCache.set(cacheKey, {
      data: updatedCache,
      timestamp: now
    });
  }
});
```

**问题所在**：
1. 当用户在规则 B（步长3）时，WebSocket 推送的区块都是步长3的（79928512、79928515、79928518）
2. 这些区块也符合规则 A（步长1）的条件（因为步长1接受所有区块）
3. 所以规则 A 的缓存被步长3的数据覆盖了
4. 切换回规则 A 时，看到的是步长3的数据

### 示例场景

1. **初始状态**：
   - 规则 A（步长1）缓存：79928510, 79928511, 79928512, 79928513, ...
   - 规则 B（步长3）缓存：空

2. **切换到规则 B（步长3）**：
   - 从后端加载步长3的数据：79928512, 79928515, 79928518, ...
   - 规则 B 缓存：79928512, 79928515, 79928518, ...

3. **WebSocket 推送新区块（79928521）**：
   - 当前规则是 B（步长3），所以推送的是步长3的区块
   - 检查规则 A（步长1）：79928521 符合步长1 ✅
   - ❌ **错误**：将 79928521 添加到规则 A 的缓存
   - 规则 A 缓存变成：79928521, 79928510, 79928511, 79928512, ...（数据混乱）

4. **继续推送（79928524、79928527）**：
   - 规则 A 缓存：79928527, 79928524, 79928521, 79928510, ...（完全混乱）

5. **切换回规则 A**：
   - 使用缓存，显示：79928527, 79928524, 79928521, ...
   - ❌ 数据跳跃，不连续

## 解决方案

### 方案1：禁用 WebSocket 同步更新其他规则缓存（推荐）✅

**核心思路**：只更新当前激活规则的缓存，不更新其他规则的缓存。

**理由**：
1. WebSocket 推送的数据是基于当前规则过滤的
2. 这些数据不适合其他规则
3. 其他规则应该从后端重新加载数据

**实现**：
```typescript
// 只更新当前激活规则的缓存
if (currentRule) {
  const currentCacheKey = `${currentRule.value}-${currentRule.startBlock}`;
  newCache.set(currentCacheKey, {
    data: updated,
    timestamp: now
  });
}

// ❌ 删除：不再同步更新其他规则的缓存
```

### 方案2：使缓存失效而不是更新（备选）

**核心思路**：当 WebSocket 推送新区块时，使其他规则的缓存失效（删除），而不是更新。

**实现**：
```typescript
// 使其他规则的缓存失效
Array.from(newCache.keys()).forEach(cacheKey => {
  if (cacheKey !== currentCacheKey) {
    newCache.delete(cacheKey);
  }
});
```

### 方案3：强制重新加载（最简单）✅

**核心思路**：规则切换时，总是强制从后端重新加载数据，不使用缓存。

**实现**：
```typescript
// 规则切换时强制重新加载
loadHistoryBlocks(true);  // forceReload=true
```

## 推荐方案

**组合方案：方案1 + 缓存过期时间缩短**

1. **禁用 WebSocket 同步更新其他规则缓存**
   - 只更新当前规则
   - 避免数据混乱

2. **缩短缓存过期时间（30秒 → 10秒）**
   - 更快地检测到数据过期
   - 自动重新加载最新数据

3. **保留缓存机制**
   - 频繁切换同一规则时仍然有效
   - 性能优化仍然有效

## 为什么之前的方案失败了？

之前的方案假设：
- WebSocket 推送的是**所有**新区块
- 可以根据规则过滤后更新对应的缓存

但实际情况是：
- WebSocket 推送的是**当前规则过滤后**的区块
- 这些区块不适合其他规则
- 强行更新会导致数据混乱

## 实施优先级

1. **立即实施**：方案1（禁用同步更新）
   - 解决数据混乱问题
   - 简单有效

2. **可选实施**：缩短缓存过期时间
   - 提高数据新鲜度
   - 减少使用旧缓存的概率

3. **备选方案**：方案3（强制重新加载）
   - 如果方案1仍有问题，使用此方案
   - 牺牲性能，保证数据准确性
